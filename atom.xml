<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qihui</title>
  
  <subtitle>倘只看书，便变成书橱</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-20T06:30:21.498Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>齐辉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java集合框架</title>
    <link href="http://yoursite.com/2018/12/20/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/12/20/java集合框架/</id>
    <published>2018-12-20T06:27:27.840Z</published>
    <updated>2018-12-20T06:30:21.498Z</updated>
    
    <content type="html"><![CDATA[<h4 id="java的集合"><a href="#java的集合" class="headerlink" title="java的集合"></a>java的集合</h4><ul><li>面向对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象的操作，Java就提供了集合类。常用的集合有List集合,Set集合和Map集合.其中List集合和Set集合继承Collection接口,各接口还提供了不同的类.<h5 id="Java集合类之间的继承关系"><a href="#Java集合类之间的继承关系" class="headerlink" title="Java集合类之间的继承关系"></a>Java集合类之间的继承关系</h5>Java集合类之间的继承关系</li><li>java的集合类主要是有两个接口派生而出的: Collection和Map</li><li>Collection和Map是Java集合框架的根接口</li></ul><p>Java集合类之间的继承关系:<br>Java的集合类主要由两个接口派生而出：Collection和Map,<br>Collection和Map是Java集合框架的根接口。<br><img src="/img/java/1.png" alt="enter description here"></p><a id="more"></a><p>图中，ArrayList,HashSet,LinkedList,TreeSet是我们经常会有用到的已实现的集合类。</p><h5 id="集合与数组的区别"><a href="#集合与数组的区别" class="headerlink" title="集合与数组的区别"></a>集合与数组的区别</h5><ul><li>长度不同,<ul><li>数组的长度是固定的</li><li>集合的长度是可变的</li></ul></li><li>储存数据类型的区别<ul><li>数组可以储存基本数据类型,也可以储存引用数据类型</li><li>集合只能储存引用数据类型</li></ul></li><li>内容区别<ul><li>数组只能储存同种的数据类型</li><li>集合可以储存不同的数据类型</li></ul></li></ul><h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h4><ul><li><p>简介</p><ul><li>Collection接口是Set,List的父接口。该接口不能直接操作,Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作。由于List接口与Set接口都继承Collection接口,因此这些方法对于List集合和Set集合都是通用的.</li></ul></li><li><p>接口中定义的方法<br>  <img src="/img/java/Collection接口.png" alt="enter description here"><br>  可以看出Collection用法有：添加元素，删除元素，返回Collection集合的个数以及清空集合等。<br>  其中重点介绍iterator()方法，该方法的返回值是Iterator<e></e></p><p>  使用Iterator遍历集合元素<br>  Iterator接口经常被称作迭代器，它是Collection接口的父接口。但Iterator主要用于遍历集合中的元素。<br>  Iterator接口中主要定义了2个方法：<br><img src="/img/java/Iterator.png" alt="enter description here"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // Iterator iterator():     使用迭代器进行遍历(重点*********)</span><br><span class="line">        // 创建Collection集合对象</span><br><span class="line">        Collection col = new ArrayList() ;</span><br><span class="line">        // 添加元素</span><br><span class="line">        col.add(&quot;张三&quot;) ;</span><br><span class="line">        col.add(&quot;李四&quot;) ;</span><br><span class="line">        col.add(&quot;王五&quot;) ;</span><br><span class="line">        col.add(&quot;赵六&quot;) ;</span><br><span class="line">        // 使用迭代器对其进行遍历</span><br><span class="line">        // 1. 获取迭代器对象</span><br><span class="line">        Iterator it = col.iterator() ;   // 返回时实现了Iterator这个接口的子类对象</span><br><span class="line">        // 2. 调用迭代器对象中的方法完成遍历</span><br><span class="line">        // E next(): 获取元素的同时,将指针向后移动一位</span><br><span class="line">        while(it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong> : 当使用Iterator对集合元素进行迭代时,Iterator并不是把集合元素本身传给了迭代变量,而是把集合元素的值给了迭代变量(就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量),所以修改迭代变量的值对集合元素本身没有任何影响<br>例如下面这个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class IteratorExample &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        List&lt;String&gt; list =Arrays.asList(&quot;java语言&quot;,&quot;C语言&quot;,&quot;C++语言&quot;);</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            String next = iterator.next();//集合元素的值传给了迭代变量，仅仅传递了对象引用。保存的仅仅是指向对象内存空间的地址</span><br><span class="line">            next =&quot;修改后的&quot;;</span><br><span class="line">            System.out.println(next);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修改后的</span><br><span class="line">修改后的</span><br><span class="line">修改后的</span><br><span class="line">[java语言, C语言, C++语言]</span><br></pre></td></tr></table></figure></p><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><p>List集合包含List接口以及List接口所有实现的类,List集合中的元素可以重复,各元素的的顺序就是对象插入的顺序.类似数组,用户可以通过索引来访问集合中的元素.</p><h5 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h5><ul><li>List接口继承了Collection接口,因此包含了Collection中所有的方法,此外List接口还定义了已下两个重要的方法<pre><code>* get(int index)  获取指定索引位置的元素* set(int index, Object obj) 将集合指定索引位置的对象修改为指定对象</code></pre><h5 id="List接口实现的类"><a href="#List接口实现的类" class="headerlink" title="List接口实现的类"></a>List接口实现的类</h5>比较常用的类有ArrayList和LinkedList，还有一个比较类似的Vector</li><li>ArrayList<ul><li>是使用的动态数组来实现的,对于数据的随机get和set或是少量数据的插入或删除,效率会比较高.ArrayList是线程不安全的,在不考虑线程安全的情况下速度也比较快.ArrayList插入数据可以重复,也是有序的,按照插入的顺序来排序.<br>根据序号来读取数据只需要直接获取数组对应的脚标数据.</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class ListTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        List&lt;String&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">        arrayList.add(&quot;1&quot;);</span><br><span class="line">        arrayList.add(&quot;1&quot;);</span><br><span class="line">        arrayList.add(&quot;2&quot;);</span><br><span class="line">        arrayList.remove(&quot;1&quot;);</span><br><span class="line">        for(String s : arrayList)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出: </span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><ul><li><p>LinkedList</p><ul><li>内部是使用链表的形式来实现的,在插入大量数据的时候效率比较快</li><li>LinkedList根据序号获取数据,是二分进行遍历,如果序号小于总长度的一半,就从链表头部开始往后遍历,直到找到对应的序号.如果序号大于总长度的一半，就从链表尾部往前进行遍历，直到找到对应的序号。拿到数据。</li><li>链表实现的代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">往容器最后面添加元素的代码是:</span><br><span class="line"> /**</span><br><span class="line">     * Pointer to first node.</span><br><span class="line">     * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line">     *            (first.prev == null &amp;&amp; first.item != null)</span><br><span class="line">     */</span><br><span class="line">    transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Pointer to last node.</span><br><span class="line">     * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line">     *            (last.next == null &amp;&amp; last.item != null)</span><br><span class="line">     */</span><br><span class="line">    transient Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">往容器最前面添加元素的代码</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    if (f == null)</span><br><span class="line">        last = newNode;</span><br><span class="line">    else</span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line">根据序号获取数据：</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    //判断index序号是否是合法的</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    // assert isElementIndex(index);</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;//判断序号在总长度一半之前还是之后</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        for (int i = 0; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Vector</p><ul><li>Vector的使用方法和内部实现基本和ArrayList相同，只不过它在add(), remove(), get()等方法中都加了同步。所以它是线程安全的。但是使用效率上就不如ArrayList了。</li></ul></li></ul><h4 id="Set集合【一般使用的有TreeSet和HashSet】"><a href="#Set集合【一般使用的有TreeSet和HashSet】" class="headerlink" title="Set集合【一般使用的有TreeSet和HashSet】"></a>Set集合【一般使用的有TreeSet和HashSet】</h4><p>Set集合与Collection集合基本相同,继承了Collection接口,因此包含了Collection中所有的方法。实际上Set就是Collection，只是行为略有不同（Set不允许包含重复元素）。<br>Set集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个Set集合中，则添加操作失败，add()方法返回false，且新元素不会被加入。</p><ul><li>HashSet是根据hashCode来决定存储位置的，是通过HashMap实现的，所以对象必须实现hashCode()方法，存储的数据无序不能重复，可以存储null,但是只能存一个。</li><li>TreeSet是根据二叉树实现的，也就是TreeMap, 放入数据不能重复且不能为null,可以重写compareTo()方法来确定元素大小，从而进行升序排序。</li></ul><h4 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h4><ul><li>Map集合没有继承Collection接口,其提供的是Key到Value的映射.</li><li>键（key值）不可重复，value值可以重复，一个value值可以和很多key值形成对应关系，每个建最多只能映射到一个值。</li><li>Map中的键值对以Entry类型的对象实例形式存在；</li><li>Map支持泛型，形式如：Map&lt;K,V&gt;</li><li>Map中使用put(K key,V value)方法添加</li></ul><h5 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h5><p>Map接口提供了Key映射到值的对象.一个映射不能包含重复的key,每个key最多只能映射到一个值.Map同样提供了集合常用的方法.<br><img src="/img/java/map接口方法.png" alt="enter description here"></p><h4 id="Map实现的类"><a href="#Map实现的类" class="headerlink" title="Map实现的类"></a>Map实现的类</h4><p>Map接口常用的实现类有: HashMap，TreeMap，HashTable.<br>Map用户保存具有映射关系的数据，因此Map集合里保存着两组数，一组值用户保存Map里的key,另一组值用户保存Map里的value，key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较总是返回false。</p><ul><li>Map集合与Set集合、List集合的关系<br>1.与Set集合的关系<br>如果 把Map里的所有key放在一起看，它们就组成了一个Set集合（所有的key没有顺序，key与key之间不能重复），实际上Map确实包含了一个keySet()方法，用户返回Map里所有key组成的Set集合。<br>2.与List集合的关系<br>如果把Map里的所有value放在一起来看，它们又非常类似于一个List：元素与元素之间可以重复，每个元素可以根据索引来查找，只是Map中索引不再使用整数值，而是以另外一个对象作为索引。</li><li><p>hashMap<br>我们最常用的Map，它根据key的HashCode 值来存储数据,根据key可以直接获取它的Value，同时它具有很快的访问速度。HashMap最多只允许一条记录的key值为Null(多条会覆盖);允许多条记录的Value为 Null。非同步的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">hashMap.put(&quot;1&quot;, &quot;a&quot;);//存储</span><br><span class="line">hashMap.put(&quot;2&quot;, &quot;b&quot;);</span><br><span class="line"></span><br><span class="line">hashMap.remove(&quot;1&quot;);//根据key来删除</span><br><span class="line">hashMap.get(&quot;2&quot;);//根据key获取</span><br><span class="line"></span><br><span class="line">//map的遍历,有很多方法遍历,这里只列举一种。</span><br><span class="line">for(Map.Entry&lt;String, String&gt; entry : hashMap.entrySet())&#123;</span><br><span class="line">    entry.getKey();//获取key</span><br><span class="line">    entry.getValue();//获取value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TreeMap</p><ul><li>TreeMap的使用大致跟HashMap类似，但是内部实现是根据红黑树来实现的。红黑树是一种平衡有序的二叉树，TreeMap的插入删除查询都是依据红黑树的规则来进行的。</li></ul></li><li>HashTable<ul><li>HashMap和TreeMap都是线程不安全的,多线程操作的时候可能会造成数据错误。Hashtable是线程安全的。其他内部实现，与HashMap都是一样的。</li></ul></li></ul><h4 id="Queue集合"><a href="#Queue集合" class="headerlink" title="Queue集合"></a>Queue集合</h4><ul><li>Queue用户模拟队列这种数据结构，队列通常是指“先进先出”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。</li><li>队列的种类<br>单队列（单队列就是常见的队列, 每次添加元素时，都是添加到队尾，存在“假溢出”的问题也就是明明有位置却不能添加的情况）<br>循环队列（避免了“假溢出”的问题）</li><li>Java 集合框架中的队列 Queue<ul><li>Java 集合中的 Queue 继承自 Collection 接口 ，Deque, LinkedList, PriorityQueue, BlockingQueue 等类都实现了它。Queue 用来存放 等待处理元素 的集合，这种场景一般用于缓冲、并发访问。除了继承 Collection 接口的一些方法，Queue 还添加了额外的 添加、删除、查询操作。</li></ul></li></ul><p>接口中定义的方法<br><img src="/img/java/Queue集合.png" alt="enter description here"></p><h4 id="Queue队列"><a href="#Queue队列" class="headerlink" title="Queue队列"></a>Queue队列</h4><ul><li>什么是队列<br>队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。</li><li>队列的种类<br>单队列（单队列就是常见的队列, 每次添加元素时，都是添加到队尾，存在“假溢出”的问题也就是明明有位置却不能添加的情况）<br>循环队列（避免了“假溢出”的问题）</li><li>Java 集合框架中的队列 Queue<ul><li>Java 集合中的 Queue 继承自 Collection 接口 ，Deque, LinkedList, PriorityQueue, BlockingQueue 等类都实现了它。Queue 用来存放 等待处理元素 的集合，这种场景一般用于缓冲、并发访问。除了继承 Collection 接口的一些方法，Queue 还添加了额外的 添加、删除、查询操作。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;java的集合&quot;&gt;&lt;a href=&quot;#java的集合&quot; class=&quot;headerlink&quot; title=&quot;java的集合&quot;&gt;&lt;/a&gt;java的集合&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;面向对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象的操作，Java就提供了集合类。常用的集合有List集合,Set集合和Map集合.其中List集合和Set集合继承Collection接口,各接口还提供了不同的类.&lt;h5 id=&quot;Java集合类之间的继承关系&quot;&gt;&lt;a href=&quot;#Java集合类之间的继承关系&quot; class=&quot;headerlink&quot; title=&quot;Java集合类之间的继承关系&quot;&gt;&lt;/a&gt;Java集合类之间的继承关系&lt;/h5&gt;Java集合类之间的继承关系&lt;/li&gt;
&lt;li&gt;java的集合类主要是有两个接口派生而出的: Collection和Map&lt;/li&gt;
&lt;li&gt;Collection和Map是Java集合框架的根接口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java集合类之间的继承关系:&lt;br&gt;Java的集合类主要由两个接口派生而出：Collection和Map,&lt;br&gt;Collection和Map是Java集合框架的根接口。&lt;br&gt;&lt;img src=&quot;/img/java/1.png&quot; alt=&quot;enter description here&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础(七) 类,对象与接口</title>
    <link href="http://yoursite.com/2018/12/19/java/java%E5%9F%BA%E7%A1%80(%E4%B8%83)%20%E7%B1%BB,%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/12/19/java/java基础(七) 类,对象与接口/</id>
    <published>2018-12-19T08:51:54.666Z</published>
    <updated>2018-12-19T00:50:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类的概念"><a href="#类的概念" class="headerlink" title="类的概念"></a>类的概念</h4><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><ul><li>一个类可以包含以下类型变量：<ul><li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。<pre><code>变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</code></pre></li><li>成员变量：成员变量是定义在类中，方法体之外的变量。<pre><code>这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</code></pre></li><li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li><li>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。<br>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法</li></ul></li></ul><a id="more"></a><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><ul><li>抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</li><li>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractClassExample &#123;</span><br><span class="line"></span><br><span class="line">    protected int x;</span><br><span class="line">    private int y;</span><br><span class="line"></span><br><span class="line">    public abstract void func1();</span><br><span class="line"></span><br><span class="line">    public void func2() &#123;</span><br><span class="line">        System.out.println(&quot;func2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AbstractExtendClassExample extends AbstractClassExample &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void func1() &#123;</span><br><span class="line">        System.out.println(&quot;func1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul><li>创建对象<br>对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步：</li><li>声明：声明一个对象，包括对象名称和对象类型。</li><li>实例化：使用关键字new来创建一个对象。</li><li>初始化：使用new创建对象时，会调用构造方法初始化对象。</li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li>接口: java编程语言中的抽象类型,是抽象方法的集合,接口通常以interface来声明.<ul><li>一个类通过继承的接口的方式,从而继承接口的抽象方法.</li><li>类实现接口通常用implements表示<ul><li>格式: class 类名 implements 接口名{}</li></ul></li><li>接口不能实例化,需要用多态的方式去实现,接口子类重写</li><li>接口的子类<ul><li>可以是抽象类,但是意义不大</li><li>可以是具体类,要重写接口中的所有的抽象方法(推荐)</li></ul></li></ul></li><li>类实现接口<pre><code>当类实现接口时,类要实现接口中所有的方法,否者类必须声明为抽象类,类使用implements关键字实现接口.在类声明中,implement声明放在class后面</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//接口</span><br><span class="line"></span><br><span class="line">interface Animal&#123;</span><br><span class="line">public void eat();</span><br><span class="line"></span><br><span class="line">public void travel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MammalInt implements Animal&#123;</span><br><span class="line">public void eat()&#123;</span><br><span class="line">System.out.println(&quot;MammalInt eat&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void travel()&#123;</span><br><span class="line">System.out.println(&quot;MammalInt travel&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int onOfLegs()&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args [])&#123;</span><br><span class="line">MammalInt m = new MammalInt();</span><br><span class="line">m.eat();</span><br><span class="line">m.travel();</span><br><span class="line">m.onOfLegs();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="接口与类不同点"><a href="#接口与类不同点" class="headerlink" title="接口与类不同点"></a>接口与类不同点</h4><ul><li><p>接口并不是类,编写接口的方式和类很相似,但是属于不同的概念.<br>类描述对象的属性和方法,接口则包含类要实现的方法<br>除非要实现接口的类是抽象类,否则该类要定义接口的所有方法</p></li><li><p>接口无法被实例化,但是可以被实现.一个实现接口的类,必须实现接口内所描述的所有方法,否者必须声明为抽象类.</p></li><li><p>接口与类相似点：</p><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul></li><li><p>接口与类的区别：</p><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul></li><li><p>接口成员特点</p><ul><li>成员变量: 接口的变量默认是常量无法修改, 只能是常量,并且是静态的,<pre><code>默认修饰的 public static final</code></pre></li><li>构造方法:<pre><code>接口没有构造方法</code></pre></li><li>成员方法: 只能是抽象方法<pre><code>默认修饰方法 public abstract建议手动给出</code></pre></li></ul></li></ul><p>所有的都默认继承一个类: object();<br>类object是类层次结构的根类.每个类都使用object作为超类</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;类的概念&quot;&gt;&lt;a href=&quot;#类的概念&quot; class=&quot;headerlink&quot; title=&quot;类的概念&quot;&gt;&lt;/a&gt;类的概念&lt;/h4&gt;&lt;h5 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;一个类可以包含以下类型变量：&lt;ul&gt;
&lt;li&gt;局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。&lt;pre&gt;&lt;code&gt;变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;成员变量：成员变量是定义在类中，方法体之外的变量。&lt;pre&gt;&lt;code&gt;这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。&lt;/li&gt;
&lt;li&gt;每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。&lt;br&gt;在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="新建,模板,小书匠" scheme="http://yoursite.com/tags/%E6%96%B0%E5%BB%BA-%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0/"/>
    
  </entry>
  
  <entry>
    <title>java基础(六) java封装继承多态</title>
    <link href="http://yoursite.com/2018/12/17/java/java%E5%9F%BA%E7%A1%80(%E5%85%AD)%20java%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2018/12/17/java/java基础(六) java封装继承多态/</id>
    <published>2018-12-17T07:35:45.125Z</published>
    <updated>2018-12-17T07:52:00.290Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h4><ul><li>有三个特征<ul><li>封装</li><li>继承</li><li>多态<h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5>是指隐藏对象的属性和实现细节，仅对外提供公共访问方式</li></ul></li><li>原则: <pre><code>将不需要的对外提供的内容隐藏起来,把属性隐藏，提供公共的对外访问方法</code></pre></li><li><p>封装的优点</p><pre><code>1. 良好的封装能够减少耦合。2. 类内部的结构可以自由修改。3. 可以对成员变量进行更精确的控制。4. 隐藏信息，实现细节。</code></pre><ul><li>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</li><li>注意到gender属性使用int数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</li></ul></li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int gender;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public String getGender() &#123;</span><br><span class="line">        return gender == 0 ? &quot;man&quot; : &quot;woman&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void work() &#123;</span><br><span class="line">        if (18 &lt;= age &amp;&amp; age &lt;= 50) &#123;</span><br><span class="line">            System.out.println(name + &quot; is working very hard!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(name + &quot; can&apos;t work any more!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>构造方法<br>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。<br>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p><ul><li>构造方法概述和作用<br>  给对象中的成员进行初始化</li><li>构造方法格式特点<br>  方法名与类名相同；没有返回值类型，连void都没有</li><li>构造方法注意事项<br>如果我们没有给出构造方法，系统将自动提供一个无参构造方法。<br>如果我们给出了构造方法，系统将不再提供默认的无参构造方法。</li><li>注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Puppy&#123;</span><br><span class="line">    public Puppy()&#123;</span><br><span class="line">//无参构造方法</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Puppy(String name)&#123;</span><br><span class="line">        // 这个构造器仅有一个参数：name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>paivate关键字</p><ul><li>private关键字特点<br>  是一个权限修饰符<br>  可以修饰成员变量和成员方法<br>  被其修饰的成员只能在本类中被访问<br>  private最常见的应用<br>  把成员变量用private修饰，提供对应的getXxx()和setXxx()方法</li></ul></li><li>this关键字<ul><li>为什么要有this<br>  当我们的局部变量和成员变量相同的时候,如果我们不使用this关键字,那么会导致一个问题:就是局部变量隐藏了成员变量的问题</li><li>this关键字特点<br>  是当前类的对象引用<br>  简单的记，它就代表当前类的一个对象。谁调用这个方法,那么该方法的内部的this就代表谁</li><li>this的应用场景<br>  解决局部变量隐藏成员变量</li></ul></li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是子类继承父类的特征和行为,使得子类对象(实例)具有父类的实例域和方法,或子类从父类继承方法,使子类具有父类的行为.</p><ul><li>继承的特性<ul><li>子类拥有父类非private的属性，方法。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li><li>Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。</li><li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul></li><li>继承的格式<ul><li>在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/父类 动物</span><br><span class="line">class Animal&#123;</span><br><span class="line">private String name;</span><br><span class="line">private int id;</span><br><span class="line"></span><br><span class="line">public Animal(String myName, int myId)&#123;</span><br><span class="line">name = myName;</span><br><span class="line">id = myId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void eat()&#123;</span><br><span class="line">System.out.println(name+&quot;正在吃&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sleep()&#123;</span><br><span class="line">System.out.println(name+&quot;正在谁&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//介绍 introduction</span><br><span class="line">public void introduction()&#123;</span><br><span class="line">System.out.println(&quot;我是&quot;+  id  +&quot;的&quot;+name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子类 企鹅</span><br><span class="line">class Penguin extends Animal&#123;</span><br><span class="line">public Penguin(String myName, int myId)&#123;</span><br><span class="line">super(myName,myId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子类 老鼠</span><br><span class="line">class Mouse extends Animal&#123;</span><br><span class="line">public Mouse(String myName,int myId)&#123;</span><br><span class="line">super(myName,myId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AnimalDemo&#123;</span><br><span class="line">public AnimalDemo()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String [] args)&#123;</span><br><span class="line">Penguin p = new Penguin(&quot;企鹅&quot;,1);</span><br><span class="line">p.eat();</span><br><span class="line">p.sleep();</span><br><span class="line">p.introduction();</span><br><span class="line"></span><br><span class="line">Mouse m = new Mouse(&quot;老鼠&quot;,2);</span><br><span class="line">m.eat();</span><br><span class="line">m.sleep();</span><br><span class="line">m.introduction();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>继承类型<br>需要注意的是 Java 不支持多继承，但支持多重继承。<br><img src="/img/es6/types_of_inheritance_1.png" alt="enter description here"></li><li><p>继承关键字<br>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。</p></li><li><p>extends关键字<br>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123; </span><br><span class="line">    private String name;   </span><br><span class="line">    private int id; </span><br><span class="line">    public Animal(String myName, String myid) &#123; </span><br><span class="line">        //初始化属性值</span><br><span class="line">    &#125; </span><br><span class="line">    public void eat() &#123;  //吃东西方法的具体实现  &#125; </span><br><span class="line">    public void sleep() &#123; //睡觉方法的具体实现  &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">public class Penguin  extends  Animal&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li>多态: 多态是同一个行为具有不同表现的形式或形态的能力<pre><code>多态就是一个接口,使用不同实例而执行不同操作多态是对象多种表现形式的体现    </code></pre></li><li>多态的优点<pre><code>1.消除类型之间的耦合关系2.可替换性3.可扩充性4.接口器5.灵活性6.简化性</code></pre></li><li>缺点<pre><code>不能使用子类的特有的功能解决: 把父类中的引用强制转换成子类的引用(向下转型)        Fu f = new Zi();        Zi z = (zi)f;  //向下转型    </code></pre></li><li>对象之间的转型<pre><code>向上转型    Fu f = new Zi();向下转型    Zi z = (zi)f;  //要求改f必须是能够转换成Zi的        </code></pre></li><li>多态存在的三个必要条件<pre><code>继承重写父类引用子类对象</code></pre></li><li><p>多态的实现方式<br>  方式一：重写<br>  方式二：接口<br>  方式三：抽象类和抽象方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">多态</span><br><span class="line">*</span><br><span class="line">/</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String args [])&#123;</span><br><span class="line">show(new Cat()); //以Cat对象调用show方法</span><br><span class="line">show(new Dog()); //以Dog对象调用show方法</span><br><span class="line"></span><br><span class="line">Animal a = new Cat(); //向上转型</span><br><span class="line">a.eat();//调用的事Cat的eat方法</span><br><span class="line">Cat c = (Cat)a;  //向下转型</span><br><span class="line">c.work();   //调用的是Cat的work方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void show(Animal a)&#123;</span><br><span class="line">a.eat();</span><br><span class="line">//类型判断</span><br><span class="line">if( a instanceof Cat)&#123;//猫做的事</span><br><span class="line">Cat c = (Cat)a;</span><br><span class="line">c.work();</span><br><span class="line">&#125;else if(a instanceof Dog)&#123;//狗做的事</span><br><span class="line">Dog c = (Dog)a;</span><br><span class="line">c.work();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Animal&#123;</span><br><span class="line">abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">public void eat()&#123;</span><br><span class="line">System.out.println(&quot;吃鱼&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void work()&#123;</span><br><span class="line">System.out.println(&quot;抓老鼠&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">public void eat()&#123;</span><br><span class="line">System.out.println(&quot;吃骨头&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void work()&#123;</span><br><span class="line">System.out.println(&quot;看家&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多态的成员访问特点</p><pre><code>访问成员变量    编译看左边,运行也看左边构造方法    创建子类对象的时候,访问父类的构造方法,对父类的数据进行初始化成员方法    编译看左边,运行看右边静态方法    编译看左边,运行看左边    (静态方法和类有关,算不上重写,所以,访问还是看左边)由于成员方法存在方法重写,所以运行时看右边</code></pre></li><li><p>多态报错<br>ClassCastException 类型转换异常, 一般在多态的向下转型中出现</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;面向对象的特征&quot;&gt;&lt;a href=&quot;#面向对象的特征&quot; class=&quot;headerlink&quot; title=&quot;面向对象的特征&quot;&gt;&lt;/a&gt;面向对象的特征&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;有三个特征&lt;ul&gt;
&lt;li&gt;封装&lt;/li&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;多态&lt;h5 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h5&gt;是指隐藏对象的属性和实现细节，仅对外提供公共访问方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原则: &lt;pre&gt;&lt;code&gt;将不需要的对外提供的内容隐藏起来,把属性隐藏，提供公共的对外访问方法
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;封装的优点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 良好的封装能够减少耦合。
2. 类内部的结构可以自由修改。
3. 可以对成员变量进行更精确的控制。
4. 隐藏信息，实现细节。
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。&lt;/li&gt;
&lt;li&gt;注意到gender属性使用int数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础(五) 面向对象</title>
    <link href="http://yoursite.com/2018/12/17/java/java%E5%9F%BA%E7%A1%80(%E4%BA%94)%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/12/17/java/java基础(五) 面向对象/</id>
    <published>2018-12-17T07:35:45.117Z</published>
    <updated>2018-12-18T01:00:08.198Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面向对象的思想"><a href="#面向对象的思想" class="headerlink" title="面向对象的思想"></a>面向对象的思想</h4><ul><li><p>在理解面向对象思想,我们可以先来看看什么是面向过程?</p><ul><li>面向过程思想概述<br>我们来回想一下，这几天我们完成一个需求的步骤：首先是搞清楚我们要做什么，然后在分析怎么做，最后我们再代码体现。<br>一步一步去实现，而具体的每一步都需要我们去实现和操作。这些步骤相互调用和协作，完成我们的需求。<br>在上面的每一个具体步骤中我们都是参与者，并且需要面对具体的每一个步骤和过程，这就是面向过程最直接的体现。<br>那么什么是面向过程开发呢? 面向过程开发，其实就是面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。<br>面向过程的代表语言：C语言</li></ul></li><li><p>然后我们再来了解面向对象</p><ul><li>面向对象思想概述<br>当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。<br>可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了。这时就开始思索，<br>能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。<br>这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。</li><li>面向对象思想特点<br>  是一种更符合我们思想习惯的思想<br>可以将复杂的事情简单化<br>将我们从执行者变成了指挥者<br>  角色发生了转换<a id="more"></a></li></ul></li></ul><h4 id="类与对象及其应用"><a href="#类与对象及其应用" class="headerlink" title="类与对象及其应用"></a>类与对象及其应用</h4><ul><li>属性： 该事物的描述信息    </li><li>行为： 该事物能够做什么    </li></ul><table><thead><tr><th>现实事物</th><th style="text-align:center">类</th></tr></thead><tbody><tr><td>属性</td><td style="text-align:center">成员变量</td></tr><tr><td>行为</td><td style="text-align:center">成员方法</td></tr></tbody></table><ul><li>类： 是一组相同属性和行为的集合。这是一个抽象的概念</li><li>对象：是该类事物的具体表现形式，具体存在的个体。<br>  例子<pre><code>学生： 类班长： 对象</code></pre></li></ul><h4 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h4><p>成员变量就是方法外部,类的内部定义的变量;<br>局部变量就是方法或语句块内部定义的变量.局部变量必须初始化.</p><ul><li>在类中的位置不同<br>成员变量：在类中方法外<br>局部变量：在方法定义中或者方法声明上</li><li>在内存中的位置不同<br>成员变量：在堆内存<br>局部变量：在栈内存</li><li>生命周期不同<br>成员变量：随着对象的创建而存在，随着对象的消失而消失<br>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</li><li>初始化值不同<br>成员变量：有默认初始化值<br>局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。<br>注意事项：: 局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则</li></ul><h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><ul><li>什么是匿名对象<br>就是没有名字的对象</li><li>匿名对象应用场景<ul><li>调用方法，仅仅只调用一次的时候。</li><li>匿名对象可以作为实际参数传递</li></ul></li></ul><h4 id="方法的重写-方法重载"><a href="#方法的重写-方法重载" class="headerlink" title="方法的重写,方法重载"></a>方法的重写,方法重载</h4><h5 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h5><ul><li>方法重写是子类对父类的允许访问方法的实现过程进行重新编写,返回值和形参都不变.<br>即外壳不变,核心改变<ul><li>方法重写好处在于子类可以根据需求定义特定自己的行为,也就是说子类可以根据需求实现父类的方法</li><li>注意: 重写的方法不能抛出新的异常或者比被重写方法申明更加宽泛的异常</li><li>当子类中应用父类被重写的方法时,要使用super关键字<br>super表示对父类对象的引用。使用了super显示的调用父类的某个构造方法后，<br>那么在执行的时候就寻找super()对应的构造方法，而不再寻找父类的不带参数的构造方法。</li><li>super必须作为构造方法的第一条执行语句。<br>在写类的时候，一定要写默认无参的构造方法，如果一个构造方法的第一句既不是this(),<br>也不是super()时，那么就会在这里隐含的调用他的父类的无参的构造方法，即隐含的调用super()。</li></ul></li><li>方法重写应用<br>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。<br>这样，即沿袭了父类的功能，又定义了子类特有的内容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*重写</span><br><span class="line">*/</span><br><span class="line">class Animal&#123;</span><br><span class="line">public void move()&#123;</span><br><span class="line">System.out.println(&quot;动物可以移动&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">public void move ()&#123;</span><br><span class="line">super.move(); //应用super类方法</span><br><span class="line">System.out.println(&quot;狗也可以跑和走&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDog&#123;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">//Animal a = new Animal();</span><br><span class="line">Animal b = new Dog();</span><br><span class="line"></span><br><span class="line">//a.move();// 执行 Animal 类的方法</span><br><span class="line"> </span><br><span class="line">        b.move();//执行 Dog 类的方法</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h5><ul><li>重载: overload是在一个类里面,方法名字相同,而参数不同,返回类型可以相同也可以不同<ul><li>每一个重载的方法(或者构造函数)都必须有一个独一无二的参数型列表</li><li>最常用的就是构造器重载</li><li>被重载的方法必须改变参数列表(参数的个数或类型不一样)</li></ul></li><li>方法重载原则<br>方法名相同；方法的参数类型不同，或者参数个数不同；与方法的参数名，返回类型和修饰符无关</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 重载</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">public class OverLoading&#123;</span><br><span class="line">public int test()&#123;</span><br><span class="line">System.out.println(&quot;test1&quot;);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">//一个参数</span><br><span class="line">public void test(int a)&#123;</span><br><span class="line">System.out.println(&quot;test2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//以下两个参数顺序不同</span><br><span class="line">public String test(int a,String s)&#123;</span><br><span class="line">System.out.println(&quot;test3&quot;);</span><br><span class="line">return &quot;return test3&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//以下两个参数顺序不同</span><br><span class="line">public String test(String s,int a)&#123;</span><br><span class="line">System.out.println(&quot;test4&quot;);</span><br><span class="line">return &quot;return test4&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String args [])&#123;</span><br><span class="line">OverLoading o = new OverLoading();</span><br><span class="line">System.out.println(o.test());</span><br><span class="line">o.test(1);</span><br><span class="line">System.out.println(o.test(1,&quot;test3&quot;));</span><br><span class="line">        System.out.println(o.test(&quot;test4&quot;,1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;面向对象的思想&quot;&gt;&lt;a href=&quot;#面向对象的思想&quot; class=&quot;headerlink&quot; title=&quot;面向对象的思想&quot;&gt;&lt;/a&gt;面向对象的思想&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在理解面向对象思想,我们可以先来看看什么是面向过程?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向过程思想概述&lt;br&gt;我们来回想一下，这几天我们完成一个需求的步骤：首先是搞清楚我们要做什么，然后在分析怎么做，最后我们再代码体现。&lt;br&gt;一步一步去实现，而具体的每一步都需要我们去实现和操作。这些步骤相互调用和协作，完成我们的需求。&lt;br&gt;在上面的每一个具体步骤中我们都是参与者，并且需要面对具体的每一个步骤和过程，这就是面向过程最直接的体现。&lt;br&gt;那么什么是面向过程开发呢? 面向过程开发，其实就是面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。&lt;br&gt;面向过程的代表语言：C语言&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后我们再来了解面向对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向对象思想概述&lt;br&gt;当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。&lt;br&gt;可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了。这时就开始思索，&lt;br&gt;能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。&lt;br&gt;这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。&lt;/li&gt;
&lt;li&gt;面向对象思想特点&lt;br&gt;  是一种更符合我们思想习惯的思想&lt;br&gt;可以将复杂的事情简单化&lt;br&gt;将我们从执行者变成了指挥者&lt;br&gt;  角色发生了转换
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的栈堆以及内存分配</title>
    <link href="http://yoursite.com/2018/12/17/java/Java%E4%B8%AD%E7%9A%84%E6%A0%88%E5%A0%86%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://yoursite.com/2018/12/17/java/Java中的栈堆以及内存分配/</id>
    <published>2018-12-17T02:28:04.069Z</published>
    <updated>2018-12-17T04:08:54.905Z</updated>
    
    <content type="html"><![CDATA[<h4 id="堆栈的概念"><a href="#堆栈的概念" class="headerlink" title="堆栈的概念"></a>堆栈的概念</h4><ul><li>栈<ul><li>栈: 基本数据类型,局部变量都是存放在栈内存中的,用完后消失.</li><li>特点<br>函数定义的基本数据类型变量,对象引用变量都是在栈内存中分配<br>栈内存的特点,数据一执行完毕,变量会立即释放,节约内存空间<br>栈内存的数据,没有默认初始值,需要手动定义</li><li>局部变量: 在方法定义或者方法声明上的变量都是局部变量</li></ul></li><li>堆<ul><li>堆: new创建的实例对象和数组,是存放在堆内存中的,用完之后是靠垃圾回收机制不定时清除的</li><li>特点<br>堆内存用来存放new创建的对象和数组<br>堆内存中的实体都有对应的内存地址<br>堆内存中的实体是用来封装数据的,都有默认的初始值<br>堆内存中实体不在指向时,java会启动垃圾回收机制,自动清除</li></ul></li></ul><a id="more"></a><ul><li>方法区<ul><li>又叫静态区,跟堆一样,被所有的线程共享.方法区包含所有的class和static变量</li><li>方法区中包含的都是在整个程序中永远唯一的元素.如class,static变量<h4 id="java的内存机制"><a href="#java的内存机制" class="headerlink" title="java的内存机制"></a>java的内存机制</h4></li></ul></li><li>Java把内存划分为两种: 一种是栈内存,另一种是堆内存.<ul><li>在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配.当在一段代码块定义一个变量时,Java就在栈中为这个变量分配内存空间,当超过变量的作用域后,Java会自动释放掉该变量分配的内存空间,该内存空间可以立即被另做他用.</li><li>堆内存是用来存放new创建的对象和数组,在堆中分配的内存,由Java虚拟机(JVM)的自动垃圾回收器来管理.在堆中产生了一个数组或者对象之后,还可以在栈中定义一个特殊的变量,让栈中的这个变量的取值等于数组或对象在堆内存中的首地址,栈中的这个变量就成了数组或对象的引用变量,以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象.</li><li>引用变量就相当于是为数组或者对象起的一个名称。引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。</li><li>这也是 Java 比较占内存的原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针！</li></ul></li></ul><h4 id="java中变量在内存中的分配"><a href="#java中变量在内存中的分配" class="headerlink" title="java中变量在内存中的分配"></a>java中变量在内存中的分配</h4><ul><li>对于成员变量和局部变量<ul><li>成员变量就是方法外部,类的内部定义的变量;</li><li>局部变量就是方法或语句块内部定义的变量.局部变量必须初始化.</li></ul></li><li>形式参数是局部变量,局部变量的数据存在于栈内存中. 栈内存中的局部变量随着方法的消失而消失.</li><li>成员变量储存在堆中的对象里面,由垃圾回收器负责回收.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;堆栈的概念&quot;&gt;&lt;a href=&quot;#堆栈的概念&quot; class=&quot;headerlink&quot; title=&quot;堆栈的概念&quot;&gt;&lt;/a&gt;堆栈的概念&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;栈&lt;ul&gt;
&lt;li&gt;栈: 基本数据类型,局部变量都是存放在栈内存中的,用完后消失.&lt;/li&gt;
&lt;li&gt;特点&lt;br&gt;函数定义的基本数据类型变量,对象引用变量都是在栈内存中分配&lt;br&gt;栈内存的特点,数据一执行完毕,变量会立即释放,节约内存空间&lt;br&gt;栈内存的数据,没有默认初始值,需要手动定义&lt;/li&gt;
&lt;li&gt;局部变量: 在方法定义或者方法声明上的变量都是局部变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;堆&lt;ul&gt;
&lt;li&gt;堆: new创建的实例对象和数组,是存放在堆内存中的,用完之后是靠垃圾回收机制不定时清除的&lt;/li&gt;
&lt;li&gt;特点&lt;br&gt;堆内存用来存放new创建的对象和数组&lt;br&gt;堆内存中的实体都有对应的内存地址&lt;br&gt;堆内存中的实体是用来封装数据的,都有默认的初始值&lt;br&gt;堆内存中实体不在指向时,java会启动垃圾回收机制,自动清除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java Thinking" scheme="http://yoursite.com/tags/java-Thinking/"/>
    
  </entry>
  
  <entry>
    <title>java基础(四) 泛型</title>
    <link href="http://yoursite.com/2018/12/16/java/java%E5%9F%BA%E7%A1%80(%E5%9B%9B)%20%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/12/16/java/java基础(四) 泛型/</id>
    <published>2018-12-16T13:28:32.177Z</published>
    <updated>2018-12-16T13:31:57.349Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们来看一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List arrayList = new ArrayList();</span><br><span class="line">arrayList.add(&quot;aaaa&quot;);</span><br><span class="line">arrayList.add(&quot;bbb&quot;);</span><br><span class="line">arrayList.add(100);</span><br><span class="line"></span><br><span class="line">for(int i = 0; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">String item = (String)arrayList.get(i);</span><br><span class="line">Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>毫无疑问，程序的运行结果会以崩溃结束：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: </span><br><span class="line">java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure></p><a id="more"></a><ul><li>定义了一个ArrayList类型的集合,先向其中加入两个字符串类型的值,随后加入一个Integer类型的值.这是完全没有问题的,因为此时List默认的类型为Object类型.<br>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</li></ul><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。<br>什么是泛型？为什么要使用泛型？</p><ul><li>泛型,即”参数化类型”. 一提到参数,最熟悉的就是定义方法时有形参,然后调用方法传递实参.那么参数化类型怎么理解呢?<br>顾名思义,就是讲类型由原来具体的类型参数化,类似于方法中的变量参数,此时类型也定义成参数形式(可以称之为类型形参),然后在使用(或调用)是传入具体的类型(类型实参)<br>泛型的本质是为了参数化类型(在不创建新的类型情况下,通过泛型指定的不同类型来控制形参具体限制的类型).<br>也就是说在泛型的使用过程中,操作的数据类型被指定为一个参数,这种参数类型可以用在类,接口和方法中,<br>它们分别称为<strong>泛型类,泛型接口,泛型方法</strong>.</li></ul><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><ul><li>泛型格式<ul><li>&lt;数据类型&gt; 这里的数据类型只能是引用数据类型</li><li>&lt;数据类型1 , 数据类型2 , ….&gt;</li></ul></li></ul><h4 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h4><ul><li>把运行时期的问题提前到了编译期间</li><li>避免了强制类型转换</li><li>优化的程序设计</li></ul><h4 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h4><ul><li><strong>泛型类: 把泛型定义在类上</strong><ul><li>定义格式: public class 类名&lt;泛型类型1,…&gt;</li><li>注意事项: 泛型类型必须是引用类型</li><li>泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  private T t;</span><br><span class="line"></span><br><span class="line">  public void add(T t) &#123;</span><br><span class="line">this.t = t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public T get() &#123;</span><br><span class="line">return t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();</span><br><span class="line">Box&lt;String&gt; stringBox = new Box&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">integerBox.add(new Integer(10));</span><br><span class="line">stringBox.add(new String(&quot;123132&quot;));</span><br><span class="line"></span><br><span class="line">System.out.printf(&quot;整型值为 :%d\n\n&quot;, integerBox.get());</span><br><span class="line">System.out.printf(&quot;字符串为 :%s\n&quot;, stringBox.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>泛型方法: 把泛型定义在方法上</strong><ul><li>定义格式: public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 变量名)</li><li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<e>）。<br>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。<br>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。<br>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。</e></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class GenericMethodTest&#123;</span><br><span class="line">   // 泛型方法 printArray                         </span><br><span class="line">   public static &lt; E &gt; void printArray( E[] inputArray )&#123;</span><br><span class="line">  // 输出数组元素            </span><br><span class="line"> for ( E element : inputArray )&#123;        </span><br><span class="line">System.out.printf( &quot;%s &quot;, element );</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main( String args[] )&#123;</span><br><span class="line">// 创建不同类型数组： Integer, Double 和 Character</span><br><span class="line">Integer[] intArray = &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">Double[] doubleArray = &#123; 1.1, 2.2, 3.3, 4.4 &#125;;</span><br><span class="line">Character[] charArray = &#123; &apos;H&apos;, &apos;E&apos;, &apos;L&apos;, &apos;L&apos;, &apos;O&apos; &#125;;</span><br><span class="line"></span><br><span class="line">System.out.println( &quot;整型数组元素为:&quot; );</span><br><span class="line">printArray( intArray  ); // 传递一个整型数组</span><br><span class="line"></span><br><span class="line">System.out.println( &quot;\n双精度型数组元素为:&quot; );</span><br><span class="line">printArray( doubleArray ); // 传递一个双精度型数组</span><br><span class="line"></span><br><span class="line">System.out.println( &quot;\n字符型数组元素为:&quot; );</span><br><span class="line">printArray( charArray ); // 传递一个字符型数组</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>泛型接口:把泛型定义在接口上</strong><ul><li>定义格式: public interface 接口名&lt;泛型类型&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 泛型接口的定义格式:        </span><br><span class="line"> * 修饰符  interface 接口名&lt;数据类型&gt; &#123;&#125;</span><br><span class="line"> */</span><br><span class="line">public interface Inter&lt;T&gt; &#123;</span><br><span class="line">public abstract void show(T t) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 子类是泛型类</span><br><span class="line"> */</span><br><span class="line">public class InterImpl&lt;E&gt; implements Inter&lt;E&gt; &#123;</span><br><span class="line">@Override</span><br><span class="line">public void show(E t) &#123;</span><br><span class="line">System.out.println(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Inter&lt;String&gt; inter = new InterImpl&lt;String&gt;() ;</span><br><span class="line">inter.show(&quot;hello&quot;) ;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="泛型高级之通配符"><a href="#泛型高级之通配符" class="headerlink" title="泛型高级之通配符"></a>泛型高级之通配符</h4><ul><li><p>为什么要使用通配符</p><ul><li>通配符的设计存在一定的场景，例如在使用泛型后，首先声明了一个Animal的类，而后声明了一个继承Animal类的Cat类，显然Cat类是Animal类的子类，但是List却不是List的子类型，而在程序中往往需要表达这样的逻辑关系。为了解决这种类似的场景，在泛型的参数类型的基础上新增了通配符的用法。</li></ul></li><li><p>&lt;? extends T&gt; 上界通配符</p><ul><li>上界通配符顾名思义，&lt;? extends T&gt;表示的是类型的上界【 包含自身】，因此通配的参数化类型可能是T或T的子类。正因为无法确定具体的类型是什么，add方法受限（可以添加null，因为null表示任何类型），但可以从列表中获取元素后赋值给父类型。如上图中的第一个例子，第三个add()操作会受限，原因在于List和List是List&lt;? extends Animal&gt;的子类型。</li></ul></li><li><p>&lt;? super T&gt; 下界通配符</p><ul><li>下界通配符&lt;? super T&gt;表示的是参数化类型是T的超类型（包含自身），层层至上，直至Object，编译器无从判断get()返回的对象的类型是什么，因此get()方法受限。但是可以进行add()方法，add()方法可以添加T类型和T类型的子类型，如第二个例子中首先添加了一个Cat类型对象，然后添加了两个Cat子类类型的对象，这种方法是可行的，但是如果添加一个Animal类型的对象，显然将继承的关系弄反了，是不可行的。</li></ul></li><li><p>&lt;?&gt; 无界通配符</p><ul><li>任意类型，如果没有明确，那么就是Object以及任意的Java类了<br>无界通配符用&lt;?&gt;表示，?代表了任何的一种类型，能代表任何一种类型的只有null（Object本身也算是一种类型，但却不能代表任何一种类型，所以List和List的含义是不同的，前者类型是Object，也就是继承树的最上层，而后者的类型完全是未知的）。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们来看一段代码&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List arrayList = new ArrayList();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arrayList.add(&amp;quot;aaaa&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arrayList.add(&amp;quot;bbb&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arrayList.add(100);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int i = 0; i&amp;lt; arrayList.size();i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	String item = (String)arrayList.get(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Log.d(&amp;quot;泛型测试&amp;quot;,&amp;quot;item = &amp;quot; + item);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;毫无疑问，程序的运行结果会以崩溃结束：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.lang.ClassCastException: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		java.lang.Integer cannot be cast to java.lang.String&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础(三) 常见的api</title>
    <link href="http://yoursite.com/2018/12/16/java/java%E5%9F%BA%E7%A1%80(%E4%B8%89)%20%E5%B8%B8%E8%A7%81%E7%9A%84api/"/>
    <id>http://yoursite.com/2018/12/16/java/java基础(三) 常见的api/</id>
    <published>2018-12-16T08:14:27.428Z</published>
    <updated>2018-12-17T03:18:21.957Z</updated>
    
    <content type="html"><![CDATA[<h4 id="object类"><a href="#object类" class="headerlink" title="object类"></a>object类</h4><ul><li>Object类有那些的公用方法<ul><li>equals() : 判断两个对象是否相等</li><li>clone(): 进行对象拷贝</li><li>getClass(): 返回和当前对象相关的Class对象</li><li>notify(): notifyall,wait都是用来对给定对象进行线程同步的<a id="more"></a></li></ul></li></ul><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><ul><li>String类的一些特性<ul><li>String类代表字符串.java程序中所有的字符串字面值(如: “abc”)都由此类的实例实现</li><li>字符串是常量,它的值在创建之后不可以被更改.字符串缓冲区支持可变的字符串.因为String对象不可变,所以可以被共享.</li><li>java语言提供字符串串联符号(“ + “),以及将其他对象转化成字符串的特殊支持.StringBuilder（或 StringBuffer）类及其 append 方法实现的。</li></ul></li><li><p>一旦被创建就不能改变</p><ul><li>String s = new String(“hello”)和String s = “hello”;的区别</li><li>String的特点一旦被创建就不能改变【内容不能变，引用可以变】<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A:String的特点: 一旦被创建就不能改变</span><br><span class="line">B:案例演示   </span><br><span class="line">     a:如何理解这句话</span><br><span class="line">     String s = &quot;hello&quot; ;</span><br><span class="line">     s =  &quot;world&quot; + &quot;java&quot;; 问s的结果是多少?</span><br><span class="line"></span><br><span class="line">下面这条语句一共创建了多少个对象:String s = &quot;a&quot;+&quot;b&quot;+&quot;c&quot;; 分别都是什么？</span><br><span class="line">答案：5个对象</span><br><span class="line">分别是 &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;ab&quot; , &quot;abc&quot;</span><br><span class="line">因为字符串的特点是一旦被创建就不能被改变,所有在使用常量进行相加的时候,</span><br><span class="line">都是在创建新的字符串对象</span><br><span class="line">最后在把字符串&quot;abc&quot;这个常量值赋值给引用变量s</span><br></pre></td></tr></table></figure></li></ul></li><li><p>StringBuffer类与StringBuilder类</p><ul><li>StringBuffer类概述<br>字符串缓冲区，StringBuffer是一个容器<br>我们如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。 而StringBuffer就可以解决这个问题<br>线程安全的可变的字符序列 , 安全对应的效率比较低</li><li>StringBuffer和String的区别<br>  String是不可变的字符序列<br>  StringBuffer 是可以的字符序列</li></ul></li><li>StringBuffer和String的相互转换<ul><li>String – StringBuffer<ul><li>通过构造方法</li><li>过append()方法</li></ul></li><li>StringBuffer – String<ul><li>使用substring方法</li><li>通过构造方法</li><li>通过toString()方法</li></ul></li></ul></li><li>StringBuilder类<ul><li>StringBuilder是线程不安全的，其他跟StringBuffer一样；StringBuffer和StringBuilder底层是 char[]数组实现的</li></ul></li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><p>冒泡排序原理</p><ul><li>相邻的元素两两比较,大的往后放,第一次完毕后,最大值出现在最大索引处</li><li>冒泡排序代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 冒泡排序</span><br><span class="line">* @param arr</span><br><span class="line">*/</span><br><span class="line">private static void sort(int[] arr)&#123;</span><br><span class="line">for(int y = 0; y &lt; arr.length; y++)&#123;</span><br><span class="line">for(int x = 0 ; x &lt; arr.length - 1 - y ; x++ ) &#123;</span><br><span class="line">            if(arr[x] &gt; arr[x+1]) &#123;</span><br><span class="line">                int temp = arr[x] ;</span><br><span class="line">                arr[x] = arr[x+1] ;</span><br><span class="line">                arr[x+1] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>选择排序</p><ul><li>从0索引开始，依次和后面元素比较，小的往前放，第一次完毕，最小值出现在了最小索引处</li><li>数组高级选择排序代码实现</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void selectSort(int[] arr) &#123;</span><br><span class="line">    for(int index = 0 ; index &lt; arr.length - 1 ; index++) &#123;</span><br><span class="line">        for(int x = index + 1 ; x &lt; arr.length ; x++) &#123;</span><br><span class="line">            if(arr[index] &gt; arr[x]) &#123;</span><br><span class="line">                int temp = arr[index] ;</span><br><span class="line">                arr[index] = arr[x] ;</span><br><span class="line">                arr[x] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数组高级二分查找<ul><li>每一次都查中间的那个元素，比较大或者小就能减少一半的元素</li><li>数组高级二分查找代码</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 二分查找</span><br><span class="line"> * @param arr</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static int binarySearch2(int[] arr , int value) &#123;</span><br><span class="line">    // 定义三个变量</span><br><span class="line">    int minIndex = 0 ;</span><br><span class="line">    int maxIndex = arr.length - 1 ;</span><br><span class="line">    while(minIndex &lt;= maxIndex) &#123;</span><br><span class="line">        int midIndex = (minIndex + maxIndex) &gt;&gt;&gt; 1 ;</span><br><span class="line">        // 比较</span><br><span class="line">        if(arr[midIndex] == value) &#123;</span><br><span class="line">            return midIndex ;</span><br><span class="line">        &#125;else if(arr[midIndex] &gt; value) &#123;</span><br><span class="line">            maxIndex = midIndex - 1 ;</span><br><span class="line">        &#125;else if(arr[midIndex] &lt; value) &#123;</span><br><span class="line">            minIndex = midIndex + 1 ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h4><ul><li>为什么会有基本类型包装类<ul><li>为了对基本数据类型进行更多的操作,更方便的操作,java就针对每一种基本数据类型提供了对应的类类型.</li><li>常用操作:<ul><li>常用的操作之一：用于基本数据类型与字符串之间的转换</li></ul></li></ul></li><li>基本类型和包装类的对应</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">byte           Byte</span><br><span class="line">short          Short</span><br><span class="line">int            Integer</span><br><span class="line">long           Long</span><br><span class="line">float          Float</span><br><span class="line">double         Double</span><br><span class="line">char           Character</span><br><span class="line">boolean        Boolean</span><br></pre></td></tr></table></figure><h4 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h4><ul><li>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</li><li>成员变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static final double E :         自然底数</span><br><span class="line">public static final double PI:        圆周率</span><br></pre></td></tr></table></figure><ul><li>成员方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static int abs(int a)               取绝对值</span><br><span class="line">public static double ceil(double a)        向上取整</span><br><span class="line">public static double floor(double a)       向下取整</span><br><span class="line">public static int max(int a,int b)         获取最大值</span><br><span class="line">public static int min(int a, int b)        获取最小值</span><br><span class="line">public static double pow(double a,double b)获取a的b次幂</span><br><span class="line">public static double random()              </span><br><span class="line">获取随机数  返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。</span><br><span class="line">public static int round(float a)           四舍五入</span><br><span class="line">public static double sqrt(double a)        获取正平方根</span><br></pre></td></tr></table></figure><h4 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h4><ul><li>随机类<ul><li>此类用于产生随机数如果用相同的种子创建两个 Random 实例，则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列</li><li>构造方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Random()             </span><br><span class="line">没有给定种子,使用的是默认的(当前系统的毫秒值)</span><br><span class="line">public Random(long seed) </span><br><span class="line">给定一个long类型的种子,给定以后每一次生成的随机数是相同的</span><br><span class="line">public int nextInt()</span><br><span class="line">public int nextInt(int n)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><ul><li>从JDK1.1版本开始，在处理日期和时间时，系统推荐使用Calendar类进行实现(Date的一些方法都过时了)在设计上，Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些，<br>下面就介绍一下Calendar类的使用。Calender类是一个抽象类，在实际使用时实现特定的子类的对象，<br>创建对象的过程对程序员来说是透明的，只需要使用getInstance()方法创建即可。<br>1.使用Calendar类代表当前时间<br>Calendar c = Calendar.getInstance();<br>System.out.println(c);  //返回的是一个Calendar对象<br>由于Calendar类是抽象类，且Calendar类的构造方法是protected的，所以无法使用Calendar类的构造方法来创建对象，<br>API中提供了getInstance方法用来创建对象。使用该方法获得的Calendar对象就代表当前的系统时间，<br>由于Calendar类toString实现的没有Date类那么直观，所以直接输出Calendar类的对象意义不大。</li></ul><ul><li>获取时间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用默认时区和语言环境获得一个日历</span><br><span class="line">   Calendar cal = Calendar.getInstance();</span><br><span class="line">   // 赋值时年月日时分秒常用的6个值，注意月份下标从0开始，所以取月份要+1</span><br><span class="line">   System.out.println(&quot;年:&quot; + cal.get(Calendar.YEAR));</span><br><span class="line">   System.out.println(&quot;月:&quot; + (cal.get(Calendar.MONTH) + 1));       </span><br><span class="line">   System.out.println(&quot;日:&quot; + cal.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">   System.out.println(&quot;时:&quot; + cal.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">   System.out.println(&quot;分:&quot; + cal.get(Calendar.MINUTE));</span><br><span class="line">   System.out.println(&quot;秒:&quot; + cal.get(Calendar.SECOND));</span><br></pre></td></tr></table></figure></li></ul><p>今天是2018年12月16日<br>输出为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">年:2018</span><br><span class="line">月:12</span><br><span class="line">日:16</span><br><span class="line">时:15</span><br><span class="line">分:57</span><br><span class="line">秒:39</span><br></pre></td></tr></table></figure></p><h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java中使用SimpleDateFormat类的构造函数</span><br><span class="line">SimpleDateFormat(String str)构造格式化日期的格式,</span><br><span class="line">通过format(Date date)方法将指定的日期对象格式化为指定格式的字符串.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"> </span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Date date = new Date();</span><br><span class="line">        String strDateFormat = &quot;yyyy-MM-dd HH:mm:ss&quot;;</span><br><span class="line">        SimpleDateFormat sdf = new SimpleDateFormat(strDateFormat);</span><br><span class="line">        System.out.println(sdf.format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018年12月16日16:12:53</span><br></pre></td></tr></table></figure></p><h4 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h4><ul><li>系统级类<ul><li>System 类包含一些有用的类字段和方法。它不能被实例化。</li><li>系统级操作</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;object类&quot;&gt;&lt;a href=&quot;#object类&quot; class=&quot;headerlink&quot; title=&quot;object类&quot;&gt;&lt;/a&gt;object类&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Object类有那些的公用方法&lt;ul&gt;
&lt;li&gt;equals() : 判断两个对象是否相等&lt;/li&gt;
&lt;li&gt;clone(): 进行对象拷贝&lt;/li&gt;
&lt;li&gt;getClass(): 返回和当前对象相关的Class对象&lt;/li&gt;
&lt;li&gt;notify(): notifyall,wait都是用来对给定对象进行线程同步的
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础(二) 基础知识</title>
    <link href="http://yoursite.com/2018/12/16/java/java%E5%9F%BA%E7%A1%80(%E4%BA%8C)%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/12/16/java/java基础(二) 基础知识/</id>
    <published>2018-12-16T07:56:38.313Z</published>
    <updated>2018-12-18T10:54:36.034Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-常量和变量"><a href="#1-常量和变量" class="headerlink" title="1.常量和变量"></a>1.常量和变量</h4><ul><li><strong>什么是常量?</strong><br>  值不会变的是常量<br>  常量在程序运行时是不能被修改的。</li><li><strong>什么是变量?</strong><br>  在作用域之间,在该数据类型范围内可以变化的的一个量.</li></ul><ul><li>声明变量(定义变量)<pre><code>格式: 数据类型 变量名;</code></pre></li><li>变量赋值:<pre><code>变量名 = 常量名;数据类型 变量名 = 常量名;</code></pre><a id="more"></a>    </li></ul><h4 id="2-进制"><a href="#2-进制" class="headerlink" title="2.进制"></a>2.进制</h4><ul><li><strong>二进制</strong><br>  0和1 前缀0B或者0b 比如：0B1001 转为十进制是9</li><li><strong>八进制</strong><br>  0-7 前缀0 比如：0103</li></ul><ul><li>十进制【我们常用的】<br>  0-9 没有前缀</li></ul><ul><li><strong>十进制</strong><br>  0-9 和 A-F 前缀0x或者0X 比如：0x123</li><li><strong>进制转换</strong><br>  任何进制转化为十进制公式：系数 * 底数 ^ 指数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b1010</span> = <span class="number">1</span> * <span class="number">2</span>^<span class="number">3</span> + <span class="number">0</span> *<span class="number">2</span>^<span class="number">2</span> + <span class="number">1</span>*<span class="number">2</span>^<span class="number">1</span> + <span class="number">0</span>*<span class="number">2</span>^<span class="number">0</span></span><br><span class="line">       = <span class="number">8</span> + <span class="number">0</span> + <span class="number">2</span> + <span class="number">0</span></span><br><span class="line">       = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">0123</span>  = <span class="number">1</span>*<span class="number">8</span>^<span class="number">2</span> + <span class="number">2</span>*<span class="number">8</span>^<span class="number">1</span> + <span class="number">3</span>*<span class="number">8</span>^<span class="number">0</span></span><br><span class="line">       = <span class="number">64</span> + <span class="number">16</span> + <span class="number">3</span></span><br><span class="line">        = <span class="number">83</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x123</span> = <span class="number">1</span>*<span class="number">16</span>^<span class="number">2</span> + <span class="number">2</span>*<span class="number">16</span>^<span class="number">1</span> + <span class="number">3</span>*<span class="number">16</span>^<span class="number">0</span></span><br><span class="line">           = <span class="number">256</span> + <span class="number">32</span> + <span class="number">3</span></span><br><span class="line">           = <span class="number">291</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-反码和补码"><a href="#3-反码和补码" class="headerlink" title="3.反码和补码"></a>3.反码和补码</h4><pre><code>正数的补码和原码是一样的</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">原码：0000 0101</span><br><span class="line">补码：0000 0101</span><br><span class="line"></span><br><span class="line">负数的补码是它的反码加1</span><br><span class="line">-5：</span><br><span class="line">原码：1000 0101</span><br><span class="line">反码：1111 1010</span><br><span class="line">   </span><br><span class="line">   + 1</span><br><span class="line">------------------</span><br><span class="line">补码  1111 1011</span><br></pre></td></tr></table></figure><h4 id="4-Java数据类型"><a href="#4-Java数据类型" class="headerlink" title="4.Java数据类型"></a>4.Java数据类型</h4><ul><li><strong>基本数据类型</strong></li><li>byte类型<ul><li>1个字节，8位【-128到127之间】</li></ul></li><li>short类型<ul><li>2个字节，16位【-2^15 到 2^15 -1】</li></ul></li><li>int类型<ul><li>4个字节，32位【-2^31 到 2^31 -1】</li></ul></li><li>long类型<ul><li>8个字节，64位【-2^63  到 2^63 -1】</li></ul></li><li>float类型【浮点型】<ul><li>4个字节，32位</li></ul></li><li>double类型【浮点型】<ul><li>8个字节，64位</li></ul></li><li>char类型<ul><li>2个字节，16位【1个汉字刚好2个字节】</li></ul></li><li>boolean类型<ul><li>1个字节，true和false</li></ul></li><li><strong>引用类型</strong></li></ul><ul><li>在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</li><li>对象、数组都是引用数据类型。</li><li>所有引用类型的默认值都是null。</li><li>一个引用变量可以用来引用任何与之兼容的类型。</li><li>例子：Site site = new Site(“Runoob”)。</li></ul><ul><li><strong>数据类型的转换</strong></li><li>默认转换<ul><li>1：byte,short,char—int—long—float—double</li><li>2：byte,short,char相互之间补转换，他们参与运算首先转换为int类型</li></ul></li><li>向上转换: 自动转化<ul><li>double d = 1.234L;</li></ul></li><li>向下转换: 需要强制转换<ul><li>格式: 目标类型 变量名 = (目标类型)值或变量名</li><li>int a = (int) 15.7f;</li><li>注意: </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1:在java中，任何一个整数默认为 int 类型 (1)</span><br><span class="line">2:在java种，任何一个小数，默认为 double 类型( 1.0)</span><br><span class="line">3:123L 或者 1231 编译器会将该数当成long类型</span><br><span class="line">4:12.345f 或者12.345F 编译器会将该数当成float类型</span><br></pre></td></tr></table></figure><h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><ul><li><strong>常见的字节码</strong></li></ul><ul><li>ASCII 码</li><li>GBK码</li><li>Unicode码【占2个字节】</li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><strong>常见的运算符有哪些</strong><ul><li>算术运算符</li><li>赋值运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>三目运算符</li><li>特殊运算符: 位运算符</li></ul></li><li><p><strong>算术运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+,  -,  *,  /,  %(取余), ++(自加), --(自减)</span><br></pre></td></tr></table></figure></li><li><p><strong>赋值运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">= ， += ， -= ， *= ， /= ， %=</span><br></pre></td></tr></table></figure></li><li><p><strong>关系运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==, &gt;, &lt;, =&gt;, &lt;=, !=</span><br></pre></td></tr></table></figure></li><li><p><strong>逻辑运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; ，^ ，| ，&amp;&amp; ，|| ，！ ， ^</span><br></pre></td></tr></table></figure></li><li><p><strong>三目运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a == b ？ c ： d</span><br><span class="line">格式：(条件表达式)？表达式1：表达式2</span><br></pre></td></tr></table></figure></li><li><p><strong>位运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; , | , ^ , ~ , &lt;&lt; , &gt;&gt; , &gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Java基本语句结构"><a href="#Java基本语句结构" class="headerlink" title="Java基本语句结构"></a>Java基本语句结构</h4><ul><li><strong>语句结构种类</strong><ul><li>顺序结构</li><li>选择结构</li><li>循环结构</li></ul></li><li><strong>顺序结构</strong><ul><li>从上到下依次执行</li></ul></li><li><strong>选择结构【可以嵌套】</strong><ul><li>if ， if else ， if else if …… else</li><li>switch case【支持byte，short，char，int，String】</li></ul></li><li><strong>循环结构</strong></li></ul><ul><li><p>for</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(初始化语句;判断条件语句;控制条件语句) &#123;</span><br><span class="line"> 循环体语句;</span><br><span class="line">&#125;</span><br><span class="line">第一步：先执行初始化语句，只执行一次</span><br><span class="line">第二步：执行判断条件语句</span><br><span class="line">第三部：执行循环体语句</span><br><span class="line">第四步：执行控制条件语句，然后再执行循环体语句【循环】</span><br></pre></td></tr></table></figure></li><li><p>while</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line">while(判断条件语句) &#123;</span><br><span class="line">循环体语句;</span><br><span class="line">控制条件语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>do while</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line"> 循环体语句;</span><br><span class="line">&#125;while((判断条件语句);</span><br></pre></td></tr></table></figure></li></ul><h4 id="Java方法"><a href="#Java方法" class="headerlink" title="Java方法"></a>Java方法</h4><ul><li><p><strong>定义</strong><br>方法就是完成特定功能的代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.系统方法，只需要会使用，不需要知道内部的结构</span><br><span class="line">2.自定义方法: 方法内部实现需要我们来写</span><br><span class="line">3.方法内部不能再嵌套方法</span><br></pre></td></tr></table></figure></li><li><p><strong>格式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回类型 方法名(参数类型 参数名,...)&#123;</span><br><span class="line">函数体</span><br><span class="line">return 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>修饰符: public static或者直接是public或是其他的private</li><li>返回类型: 所有的数据类型(基本类型: int, long,float,char…,引用数据类型: String)</li><li>方法名: 采用驼峰式,首字母一般小写,要见名知意</li><li>参数类型: 所有的数据类型,如果一个方法没有返回值,则这个方法值类型为void</li><li>参数名: 变量</li><li>返回值: 即返回结果(这个结果必须与返回类型一致)</li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><strong>数组的概念</strong></li></ul><ul><li>数组是一个容器,可以储存多个变量,这些变量的数据类型必须一致</li><li>数组既可以储存基本数据类型,也可以储存引用数据类型</li></ul><ul><li><strong>一维数组</strong></li></ul><ul><li>数组格式定义<br>  格式一: 数据类型【】 数组名<br>  格式二: 数据类型 数组名【】<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] a; //定义了一个int类型的数组a;</span><br><span class="line">int a[]; //定义了一个int类型的a数组;</span><br></pre></td></tr></table></figure></li></ul><ul><li>数组的初始化<ul><li>java的数组必须初始化,然后才能使用</li><li>数组初始化: 就是为数组元素中的数组分配内存空间,并为每一个数组元素赋值</li></ul></li><li>初始化分类<ul><li>动态初始化: 只指定长度,由系统给出初始值</li><li>静态初始化: 给出初始值,由系统给出长度</li><li>注意事项: 这两种方式,只能给出一种,不能动静结合</li></ul></li><li><strong>二维数组</strong></li></ul><ul><li>数组定义格式<ul><li>数据类型[][] 变量名 = new 数据类型[m][n];</li><li>m表示这个二维数组有多少个一维数组</li><li>n表示每一个一维数组的元素个数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[][] arr = new int[3][2];</span><br><span class="line">定义了一个二维数组arr</span><br><span class="line">这个二维数组有3个一维数组，名称是arr[0],arr[1],arr[2]</span><br><span class="line">每个一维数组有2个元素，可以通过arr[m][n]来获取,</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><strong>枚举: Enumeration</strong><br><strong>位集合: BitSet</strong><br><strong>向量: Vector</strong><br><strong>栈: Stack</strong><br><strong>字典: Dictionary</strong><br><strong>哈希表: Hashtable</strong><br><strong>属性: Properties</strong></p><ul><li>枚举:<ul><li>枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 </li><li>枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。</li></ul></li><li>位集合（BitSet）<ul><li>位集合类实现了一组可以单独设置和清除的位或标志。</li><li>该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，<br>然后对位进行适当的设置或清除，就可以对布尔值进行操作了。</li></ul></li><li>向量（Vector）<ul><li>向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。<br>和数组一样，Vector对象的元素也能通过索引访问。</li><li>使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。</li></ul></li><li>栈（Stack）<ul><li>栈（Stack）实现了一个后进先出（LIFO）的数据结构。</li><li>你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。</li><li>当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。</li><li>字典（Dictionary）</li></ul></li><li>字典（Dictionary） <ul><li>类是一个抽象类，它定义了键映射到值的数据结构。<br>当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。<br>由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。</li></ul></li><li>哈希表（Hashtable）<ul><li>Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。</li><li>例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。<br>哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。</li></ul></li><li>属性（Properties）<ul><li>Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。</li><li>Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-常量和变量&quot;&gt;&lt;a href=&quot;#1-常量和变量&quot; class=&quot;headerlink&quot; title=&quot;1.常量和变量&quot;&gt;&lt;/a&gt;1.常量和变量&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;什么是常量?&lt;/strong&gt;&lt;br&gt;  值不会变的是常量&lt;br&gt;  常量在程序运行时是不能被修改的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;什么是变量?&lt;/strong&gt;&lt;br&gt;  在作用域之间,在该数据类型范围内可以变化的的一个量.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;声明变量(定义变量)&lt;pre&gt;&lt;code&gt;格式: 数据类型 变量名;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;变量赋值:&lt;pre&gt;&lt;code&gt;变量名 = 常量名;
数据类型 变量名 = 常量名;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础(一)  常用关键字</title>
    <link href="http://yoursite.com/2018/12/16/java/java%E5%9F%BA%E7%A1%80(%E4%B8%80)%20%20%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2018/12/16/java/java基础(一)  常用关键字/</id>
    <published>2018-12-16T07:56:38.305Z</published>
    <updated>2018-12-17T02:56:14.351Z</updated>
    
    <content type="html"><![CDATA[<h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">基本类型</span><br><span class="line">整数</span><br><span class="line">byte short int long</span><br><span class="line">小数</span><br><span class="line">float double</span><br><span class="line">字符</span><br><span class="line">char</span><br><span class="line">布尔类型(boolean)</span><br><span class="line">true false</span><br><span class="line">访问控制</span><br><span class="line">public protected private </span><br><span class="line">程序控制</span><br><span class="line">break    continue    return    do    </span><br><span class="line">while    if    else    for    instanceof    </span><br><span class="line">switch   case    default</span><br><span class="line">类,方法以及变量修饰符</span><br><span class="line"> class abstract finalextends staticnew  implements</span><br><span class="line">nativestrictfpsynchronized    transient    volatile</span><br><span class="line">异常处理</span><br><span class="line">try catch throw throws</span><br><span class="line">包相关的</span><br><span class="line">import package</span><br><span class="line">变量引用</span><br><span class="line">this super void</span><br><span class="line">保留字</span><br><span class="line">goto const</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><ul><li><strong>整数</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">byte: 字节型</span><br><span class="line">short: 短整型</span><br><span class="line">int: 整型</span><br><span class="line">long; 长整型</span><br><span class="line">都是java的原始数据类型</span><br><span class="line">byte 1个字节，8位【-128到127之间】</span><br><span class="line">short 2个字节，16位【-2^15 到 2^15 -1】.</span><br><span class="line">int 4个字节，32位【-2^31 到 2^31 -1】</span><br><span class="line">long 8个字节，64位【-2^63 到 2^63 -1】</span><br><span class="line"></span><br><span class="line">包装对象类</span><br><span class="line">byte: Byte</span><br><span class="line">short: Short</span><br><span class="line">int: Integer</span><br><span class="line">long: Long</span><br><span class="line">    表示原始类型的包装对象类.它定义代表此类型值的范为:MIN_VALUE和MAX_VALUE常量</span><br><span class="line"></span><br><span class="line">java中所有的整数值都是32的int值,除非值后面有 l 或 L（如 235L），</span><br><span class="line">这表示该值应解释为 long</span><br></pre></td></tr></table></figure><ul><li><p><strong>小数</strong><br>  float: 浮点<br>  double: 双精度<br>  都是java原始数据类型<br>  float变量可以储存单精度福浮点值<br>  double变量可以储存双精度的浮点值</p><p>  注意:</p><pre><code>由于java默认的浮点为双精度,因此要指定单精度文字(即用float),应在后面加上f,F.如: 0.11f</code></pre><p>  由于浮点数据类型是实际数值的近视值,因此,一般不要对浮点数值进行相等的比较<br>java中的浮点数值可以代表无穷大和NAN(非数值).<br>  Float和Double包装对象类用来定义常量 MIN_VALUE、MAX_VALUE、NEGATIVE_INFINITY、POSITIVE_INFINITY 和 NaN。</p></li></ul><ul><li><strong>字符</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">char 是 Java 原始类型。char 变量可以存储一个 Unicode 字符。 </span><br><span class="line">可以使用下列 char 常量：</span><br><span class="line">\b - 空格 </span><br><span class="line">\f - 换页</span><br><span class="line">\n - 换行</span><br><span class="line">\r - 回车</span><br><span class="line">\t - 水平制表符 </span><br><span class="line">\&apos; - 单引号</span><br><span class="line">\&quot; - 双引号</span><br><span class="line">\\ - 反斜杠</span><br><span class="line">\xxx - 采用 xxx 编码的 Latin-1 字符</span><br><span class="line">\x 和 \xx 均为合法形式，但可能引起混淆</span><br><span class="line">\uxxxx - 采用十六进制编码 xxxx 的 Unicode 字符</span><br><span class="line"></span><br><span class="line"> Character 类包含一些可用来处理 char 变量的 static 方法，</span><br><span class="line"> 这些方法包括 isDigit()、isLetter()、isWhitespace() 和 toUpperCase()。</span><br></pre></td></tr></table></figure><ul><li><strong>布尔值(boolean)</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ture false</span><br><span class="line">对,错</span><br><span class="line">boolean 变量的两个合法值</span><br></pre></td></tr></table></figure><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><ul><li><p><strong>public</strong>    公共的<br>  public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用</p></li><li><p><strong>protected</strong><br>  对同一包内的类和所有子类可见。使用对象：变量、方法.protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西</p></li><li><p><strong>private</strong> 私有的<br>   private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用<br>访问权限仅限于类的内部，是一种封装的体现，例如，大多数成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问</p></li></ul><h4 id="类-方法以及变量修饰符"><a href="#类-方法以及变量修饰符" class="headerlink" title="类,方法以及变量修饰符"></a>类,方法以及变量修饰符</h4><ul><li><strong>class</strong> 类<br>  class 关键字是用来声明新的 java 类的,该类是相关变量或方法的集合.类是面向对象的程序设计方法的基本构造单位.类通常代表某种实际实体.如几何形状或人.类是对象的模板.每个对象都是类的一个实例.要使用类,通常使用  new 操作符将类的对象实例化,然后调用类的方法来访问类的功能</li></ul><ul><li><strong>abstract</strong>  抽象类<br>  在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</li></ul><ul><li><strong>final</strong> 最终的<br>  final关键字可以用于声明属性,方法和类用于类,表示类不可以扩展(不能有子类)用于方法,表示在子类中不可以重写此方法.<br>  注意:<br>  一个类不可以同时是abstract又是final.abstract意味着必须扩展类,final则不能扩展.<br>一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，final 则不能重写方法</li></ul><ul><li><strong>extends</strong> 继承、扩展<br>  extends关键字用在class或interface声明中,用于指示所声明的类或接口时其名称后跟有extends关键字的类或接口的子类.子类继承父类的所有的public和protected变量和方法. 子类可以重写父类的任何除了final的方法.一个类自能扩展一个其他的类.    </li></ul><ul><li><strong>static</strong> 静态<br>  static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）<br>  通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用 static（内部）类可以被其他类实例化和引用（即使它是顶级类）。<br>在上面的示例中，<br>另一个类中的代码可以实例化 MyStaticClass 类， 方法是用包含它的类名来限定其名称，如 MyClass.MyStaticClass。 static 字段（类的成员变量）在类的所有实例中只存在一次。 可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。<br>模式：public final static <type> varName = <value>;<br>通常用于声明可以在类的外部使用的类常量。 在引用这样的类常量时需要用类名加以限定。<br>在上面的示例中，另一个类可以用 MyClass.MAX_OBJECTS 形式来引用 MAX_OBJECTS 常量</value></type></li></ul><ul><li><p><strong>new</strong><br>  new关键字用于创建类的新实例<br>  new关键字后面的参数必须是类名,<br>  并且类名的后面必须是一组构造方法参数(必须带括号)<br>  参数集合必须与类的构造方法签名匹配<br>  左侧的变量的类型必须与要实例化的类或接口具有赋值兼容关系</p></li><li><p><strong>interface</strong> 接口<br>  interface 关键字是用来声明新的java接口,接口时方法的集合.接口是java语言的一项强大的功能.任何类都可声明它实现一个或多个接口,这意味着它实现了这些接口中所定义的所有方法实现了接口的任何类都必须提供在该接口中的所有方法实现.<br>一个类可以实现多个接口</p></li></ul><ul><li><strong>implements</strong><br>  implements关键字在class声明中使用,声明类提供了implements 关键字后面名称所指定接口所声明的所有方法.类必须实现接口的中所有方法.一个类可以实现多个接口</li></ul><h4 id="包相关"><a href="#包相关" class="headerlink" title="包相关"></a>包相关</h4><ul><li><strong>import</strong> 引入<br>  import 关键字使一个包中的一个或所有类在当前 Java 源文件中可见。可以不使用完全限定的类名来引用导入的类。 当多个包包含同名的类时，许多 Java 程序员只使用特定的 import 语句（没有“*”）来避免不确定性</li></ul><ul><li><strong>package</strong> 包<br>  package 关键字指定在 Java 源文件中声明的类所驻留的 Java 包。 package 语句（如果出现）必须是 Java 源文件中的第一个非注释性文本。 例:java.lang.Object。 如果 Java 源文件不包含 package 语句，在该文件中定义的类将位于“默认包”中。请注意，不能从非默认包中的类引用默认包中的类。</li></ul><h4 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h4><ul><li><p><strong>this</strong><br>  this 关键字用于引用当前实例。 当引用可能不明确时，可以使用 this 关键字来引用当前的实例。</p></li><li><p><strong>void</strong> 无返回值<br>  void 关键字表示 null 类型。 void 可以用作方法的返回类型，以指示该方法不返回值。</p></li><li><p><strong>super</strong><br>  super 关键字用于引用使用该关键字的类的超类。 作为独立语句出现的 super 表示调用超类的构造方法。 super.<methodname>() 表示调用超类的方法。只有在如下情况中才需要采用这种用法：要调用在该类中被重写的方法，以便指定应当调用在超类中的该方法。</methodname></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;基本类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	整数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		byte short int long&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	小数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		float double&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	字符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		char&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	布尔类型(boolean)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		true false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;访问控制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public protected private &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;程序控制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	break    continue    return    do    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	while    if    else    for    instanceof    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	switch   case    default&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;类,方法以及变量修饰符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 class abstract final	extends static	new  implements&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	native	strictfp	synchronized    transient    volatile&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;异常处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	try catch throw throws&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;包相关的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	import package&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;变量引用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	this super void&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;保留字&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	goto const&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-- String是关键字吗???</title>
    <link href="http://yoursite.com/2018/12/16/java/java--%20String%E6%98%AF%E5%85%B3%E9%94%AE%E5%AD%97%E5%90%97___/"/>
    <id>http://yoursite.com/2018/12/16/java/java-- String是关键字吗___/</id>
    <published>2018-12-16T07:56:38.303Z</published>
    <updated>2018-12-16T08:19:44.849Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helloword</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>这是学java基本都会写一个例子,这里我们可以探讨几个概念性的问题,String 是关键字（keyword）吗？ </li><li>要弄清这个问题,首先我们的了解什么是String?<br>  String是一个类名，即Class java.lang.String 的类名，也就是常说的字符串类，其对象就是字符串。 </li><li>那什么又是关键字呢?<br>  关键字是电脑语言里事先定义的,有特别意义的标识符,有时又叫保留字，还有特别意义的变量。 Java的关键字对java的编译器有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等，关键字不能用作变量名、方法名、类名、包名。 </li></ul><p><strong>既然关键字不能用作类名，那么用作类名的就不是关键字，所以，String不是关键字.</strong></p><p>这里我们还可以引申另一个知识<strong>标识符</strong>,这也是一个容易与关键弄混的概念</p><ul><li>标识符（identifier)<br>  是指类名(包括接口、枚举、抽象类)、方法名、变量、常量名、包名等可以自定义的字符组合。<br>  虽然可以自定义，但是也要遵循如下规则：<br>  由字母, 下划线, 数字, $符号组成;<br>  只能以字母、下划线、$符号开头，不能以数字开头；<br>  标识符长度没有限;<br>  区分大小写<br>  不能是关键字</li></ul><p><strong>因此我们可以得出一个结论:</strong><br><strong>String 是Java基础库中的一个常用类的类名，属于标识符(identifier)，不是关键字</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Helloword&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello world&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java Thinking" scheme="http://yoursite.com/tags/java-Thinking/"/>
    
  </entry>
  
  <entry>
    <title>node系列（三）http</title>
    <link href="http://yoursite.com/2018/12/15/node/node%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89)http/"/>
    <id>http://yoursite.com/2018/12/15/node/node系列（三)http/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-12-28T06:21:47.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><ul><li>node.js提供了HTTP模块,其中封装了一个高效的HTTP服务器和一个简易的HTTP客户端</li><li>http.Server是一个基于事件的HTTP服务器,核心是由node.js下层C++实现的,接口是由JavaScript封装的</li><li>http.request是http客户端工具,用于客户端发送请求<a id="more"></a></li></ul><h2 id="http服务端"><a href="#http服务端" class="headerlink" title="http服务端"></a>http服务端</h2><p>http.createServer创建了http.server实例,请求对象req,响应对象res,响应代码200表示请求成功<br>http.server提供了几个事件</p><ul><li>request:当客户端请求到来时, 该事件被触发,提供了两个参数req,res分别是http.ServerRequest,http.ServerResponse表示请求和响应信息</li><li>connection: 当TCP连接建立，该事件被触发，提供了一个参数socket，为net.socket实例.connection事件的粒度要大于request，因为客户端在Keep-Alive模式下可能在同一个连接内发送多次请求</li><li><p>close: 当服务器被关闭时,事件被触发</p></li><li><p>server.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载http模块</span></span><br><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>)</span><br><span class="line"><span class="comment">//创建http服务器</span></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//向请求的客户端发送响应头,http状态值: 200 : ok,内容类型</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>,&#123;<span class="string">"Content-Type"</span>:<span class="string">"text/html;charset=UTF8"</span>&#125;)</span><br><span class="line">    <span class="comment">//向请求的客户端发送响应内容(在response.end之前，可以多次调用)</span></span><br><span class="line">    res.write(<span class="string">"你好,世界"</span>)</span><br><span class="line"><span class="comment">//响应结束，告知客户端所有的发送已经完成，</span></span><br><span class="line"><span class="comment">//如果不调用改函数，客户端将处于等待状态</span></span><br><span class="line">    res.end()</span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line">&#125;).listen(<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//终端打印信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Server Runing at http//127.0.0.1:3000/, 成功"</span>)</span><br></pre></td></tr></table></figure></li></ul><p>上述代码通过require(“http”)创建一个http实例,然后使用createServer创建一个服务器,用listen监听3000端口<br>http.ServerRequest是HTTP请求的信息，是后端开发者最关注的内容<br>HTTP请求一般分为：请求头(Request Header)请求体(Request Body)</p><ul><li>http.ServerRequest提供了三个事件用于控制请求体传输<ul><li>data:请求数据到来之后该事件被触发，事件提供了一个参数chunk，表示接收到的数据，如果该事件没有被监听, 那么请求体将会被抛弃 (可能会被多次调用)</li><li>end:当请求体数据传输完成时，事件被触发，此后不再有数据到来</li><li>close:用户当前请求结束，该事件被触发，不同于end，用户强制终止传输，也还是调用close</li></ul></li></ul><h2 id="http客户端"><a href="#http客户端" class="headerlink" title="http客户端"></a>http客户端</h2><p>http模块提供了两个函数http.request和http.get,功能是作为客户端向HTTP服务器发起请求</p><h3 id="http-request"><a href="#http-request" class="headerlink" title="http.request"></a>http.request</h3><ul><li><p>client.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="comment">//请求选项</span></span><br><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">port: <span class="string">'3000'</span>,</span><br><span class="line">path: <span class="string">'/'</span>,</span><br><span class="line">method: <span class="string">'GET'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> req = http.request(options, (res)=&gt;&#123;</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line">res.on(<span class="string">'data'</span>, (data)=&gt;&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">res.end()</span><br></pre></td></tr></table></figure><p>  我们创建了一个http请求,为响应的事件添加了data事件,最后使用了res.end()初始化和发送我们的请求<br>http.request(option,callback) 发起HTTP请求，option=》关联数组 参数：</p></li><li>host:请求网站的域名或IP地址</li><li>port:请求网站的端口，默认80</li><li>method:请求方法，默认GET</li><li>path:请求的相对于根的路径</li><li>headers:一个关联数组对象，为请求头的内容</li><li>callback:传递一个参数，为http.ClientResponse实例</li><li>http.request返回一个http.ClientRequest的实例</li></ul><h3 id="http-get"><a href="#http-get" class="headerlink" title="http.get"></a>http.get</h3><p>http.get(options,callback)是http.request的简化版，唯一的区别就是http.get自动将请求的方法设为Get请求<br>同时不需要调用req.end()<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> opts = &#123;</span><br><span class="line">　　host: <span class="string">'www.google.com'</span></span><br><span class="line">　　port: <span class="number">80</span>,</span><br><span class="line">　　path: <span class="string">'/'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> req = http.get(opts, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">　　<span class="built_in">console</span>.log(res);</span><br><span class="line">　　res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">　　res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">　　　　<span class="built_in">console</span>.log(data);</span><br><span class="line">　　&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个例子和之前的例子实现同样的功能，区别就在于opts对象少了method属性，使用http.get()代替了之前的var req=http.request()和req.end()。由于返回回来的数据是2进制数据，我们需要使用response.setEncoding()实现编码</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;http模块&quot;&gt;&lt;a href=&quot;#http模块&quot; class=&quot;headerlink&quot; title=&quot;http模块&quot;&gt;&lt;/a&gt;http模块&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;node.js提供了HTTP模块,其中封装了一个高效的HTTP服务器和一个简易的HTTP客户端&lt;/li&gt;
&lt;li&gt;http.Server是一个基于事件的HTTP服务器,核心是由node.js下层C++实现的,接口是由JavaScript封装的&lt;/li&gt;
&lt;li&gt;http.request是http客户端工具,用于客户端发送请求
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（十一）Generator</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89Generator/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（十一）Generator/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-10T08:20:56.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p>Generator 就是普通函数，有两个特征：一是function关键字后面有一个星号；二是函数体内部使用yield语句定义遍历器的每个成员，即不同的内部状态<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line">hw.next();</span><br><span class="line">hw.next();</span><br><span class="line">hw.next();</span><br></pre></td></tr></table></figure></p><pre><code>Generator的本质，是提供一种可以暂停执行的函数。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Generator&quot;&gt;&lt;a href=&quot;#Generator&quot; class=&quot;headerlink&quot; title=&quot;Generator&quot;&gt;&lt;/a&gt;Generator&lt;/h1&gt;&lt;p&gt;Generator 就是普通函数，有两个特征：一是function关键字后面有一个星号；二是函数体内部使用yield语句定义遍历器的每个成员，即不同的内部状态&lt;br&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>node系列（一）总览一</title>
    <link href="http://yoursite.com/2018/12/15/node/node%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E6%80%BB%E8%A7%88%E4%B8%80/"/>
    <id>http://yoursite.com/2018/12/15/node/node系列（一）总览一/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-12-24T10:46:17.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是node"><a href="#什么是node" class="headerlink" title="什么是node?"></a>什么是node?</h2><ul><li>Node.js是一个让JS可以运行在浏览器之外的服务器端的平台</li><li>它实现了诸如文件系统、模块、包、操作系统API，网络通信等核心 JS没有或不完善的功能</li><li>它摒弃传统平台依赖多线程来实现高并发的设计思路，而采用单线程，异步式I/O，事件驱动式的程序设计模型</li><li>Node.js使用了来自Google ChromeV8引擎。V8是目前世界上最快的javascript引擎<a id="more"></a></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>所谓特点,就是node.js如何解决服务器高性能瓶颈问题的</li></ul><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><ul><li>在java,php或者.net等服务器语言中,会为客户端创建一个新的线程,而每一个线程需要消耗2mb内存.理论上,一个8GB的服务器可以同时连接最大用户为4000个左右.要让web应用程序支持更多的用户,就需要增加服务器的数量,而web应用程序的硬件成本当然也就上升了</li><li>node.js不为每一个用户创建一个新的线程,而仅仅使用一个线程.当有用户连接了,就会触发一个内部事件,通过非阻塞I/O,事件驱动机制,让node.js程序宏观上也是并行的,使用node.js,一个8GB内存的服务器,可以同时处理超过4万用户的连接</li><li>另外,单线程带来的好处就是减少内存的开销,还有操作系统完全不再有线程创建、销毁的时间开销。</li><li>坏处,就是一个用户造成的线程的崩溃,整个服务器都崩溃了,其他的人也就都崩溃了</li></ul><h3 id="非阻塞I-O-non-blocking-I-O"><a href="#非阻塞I-O-non-blocking-I-O" class="headerlink" title="非阻塞I/O  non-blocking I/O"></a>非阻塞I/O  non-blocking I/O</h3><ul><li>例如,当在访问数据库取得数据的时候,需要一段时间.当传统的单线程处理机制中,在执行了访问数据库代码之后,整个线程都将暂停下来,等待数据库返回结果,才能执行后面的代码.也就是说,I/O阻塞了代码的执行,极大的降低了程序的执行效率</li><li>由于node.js中采用了非阻塞I/O机制,因此在执行访问数据库的代码,将立即执行其他后面的代码,把数据库返回结果的处理代码放在回调函数中,从而提高了程序的执行效率.</li><li>当某个I/O执行完毕时,将以事件的形式通知执行I/O操作的线程,线程执行的这个事件的回调函数.为了处理异步I/O,线程必须有事件循环,不断的检查有没有未处理的事件,一次予以处理.</li><li>阻塞模式下,一个线程只能处理一项任务,想要提高吞吐量,必须通过多线程.而非阻塞I/O模式下,一个线程永远在执行计算操作,这个线程的CPU核心利用率永远是100%</li></ul><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><ul><li>在node.js中,客户端请求建立连接,提交数据等行为会出触发相应的事件.在node中,一个时刻只能执行一个事件的回调函数,但是在执行一个事件回调函数的中途,可以转而处理其他的事情(比如,又有新用户连接了),然后返回执行原事件的回调函数,这种处理的机制,称为”事件环”机制</li><li>mode.js底层是c++写的(V8也是用C++写的).底层代码中,近半数都是用于事件队列,回调函数队列的构建.用事件驱动来完成服务的任务调用</li></ul><h2 id="node-js的优点"><a href="#node-js的优点" class="headerlink" title="node.js的优点"></a>node.js的优点</h2><pre><code>·Nodejs基于Javascript语言·统一公共类库，代码标准化·Nodejs选择了目前最快的浏览器内核V8作为执行引擎·Nodejs的社区非常活跃 www.npmjs.com</code></pre><h2 id="适用开发"><a href="#适用开发" class="headerlink" title="适用开发"></a>适用开发</h2><ul><li>node.js适用于开发什么样的应用程序?<ul><li>善用于I/O,不善于计算.因为node.js最擅长的就是任务调用.如果的你的业务有很多的CPU计算,实际上也相当于这个计算阻塞了这个单线程,就不适合node开发.<br>当应用程序需要处理大量并发的I/O,而在向客户端发出响应之前,应用程序内部并不需要进行复杂的处理时候,node.js非常合适,node.js也非常适合与web socket配合,开发长连接的实时交互应用程序.<ul><li>比如<ul><li>用户表单的收集</li><li>聊天室</li><li>图文直播</li><li>提供JSON的API</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是node&quot;&gt;&lt;a href=&quot;#什么是node&quot; class=&quot;headerlink&quot; title=&quot;什么是node?&quot;&gt;&lt;/a&gt;什么是node?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Node.js是一个让JS可以运行在浏览器之外的服务器端的平台&lt;/li&gt;
&lt;li&gt;它实现了诸如文件系统、模块、包、操作系统API，网络通信等核心 JS没有或不完善的功能&lt;/li&gt;
&lt;li&gt;它摒弃传统平台依赖多线程来实现高并发的设计思路，而采用单线程，异步式I/O，事件驱动式的程序设计模型&lt;/li&gt;
&lt;li&gt;Node.js使用了来自Google ChromeV8引擎。V8是目前世界上最快的javascript引擎
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（十）Iterator遍历器</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%EF%BC%89Iterator%E9%81%8D%E5%8E%86%E5%99%A8/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（十）Iterator遍历器/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-10T08:20:33.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Iterator遍历器"><a href="#Iterator遍历器" class="headerlink" title="Iterator遍历器"></a>Iterator遍历器</h1><p>遍历器是一种协议，任何对象只要部署了这个协议，就可以完成遍历操作。它的主要作用有两个<br>&nbsp;&nbsp;1.一个是为遍历对象的属性提供统一的接口，<br>&nbsp;&nbsp;2.二是时对象的属性能够按次序排列。</p><p>ES6的遍历器协议规定，部署了next方法的对象，就具备了遍历器功能。<br>&nbsp;&nbsp;next方法必须返回一个包含value和done两个属性的对象。<br>&nbsp;&nbsp;value属性是当前遍历位置的值，<br>&nbsp;&nbsp;done属性是一个布尔值，表似乎遍历是否结束。<br><a id="more"></a>        </p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span> (<span class="params">array</span>) </span>{    <span class="keyword">var</span> nextIndex = <span class="number">0</span>;    <span class="keyword">return</span> {        next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{            <span class="keyword">return</span> nextIndex &lt; array.length ? {<span class="attr">value</span>:array[nextIndex++],<span class="attr">done</span>:<span class="literal">false</span>}:{<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>};        }    }}    <span class="comment">//定义了一个makeIterator函数，作用是返回一个遍历器对象，用来遍历参数数组。</span></code></pre><pre><code>ES6中，一个对象只要部署了next方法，就被视为具有Iterator接口，就可以用for...of循环遍历它的值。</code></pre><pre><code class="javascript"><span class="keyword">var</span> it = makeIterator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);<span class="keyword">for</span>(<span class="keyword">var</span> n <span class="keyword">of</span> it) {    <span class="keyword">if</span>(n&gt;it.length){        <span class="keyword">break</span>;    }    <span class="built_in">console</span>.log(n);}</code></pre><pre><code>for...in 循环读取键名；for...of循环读取键值</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Iterator遍历器&quot;&gt;&lt;a href=&quot;#Iterator遍历器&quot; class=&quot;headerlink&quot; title=&quot;Iterator遍历器&quot;&gt;&lt;/a&gt;Iterator遍历器&lt;/h1&gt;&lt;p&gt;遍历器是一种协议，任何对象只要部署了这个协议，就可以完成遍历操作。它的主要作用有两个&lt;br&gt;&amp;nbsp;&amp;nbsp;1.一个是为遍历对象的属性提供统一的接口，&lt;br&gt;&amp;nbsp;&amp;nbsp;2.二是时对象的属性能够按次序排列。&lt;/p&gt;
&lt;p&gt;ES6的遍历器协议规定，部署了next方法的对象，就具备了遍历器功能。&lt;br&gt;&amp;nbsp;&amp;nbsp;next方法必须返回一个包含value和done两个属性的对象。&lt;br&gt;&amp;nbsp;&amp;nbsp;value属性是当前遍历位置的值，&lt;br&gt;&amp;nbsp;&amp;nbsp;done属性是一个布尔值，表似乎遍历是否结束。&lt;br&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（四） for-of 循环</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%20for-of%20%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（四） for-of 循环/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-17T03:56:36.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for-of 循环"></a>for-of 循环</h1><pre><code>任何部署了Iterator接口的对象，都可以使用for-of循环遍历。我们如何遍历数组中的元素：</code></pre><h2 id="（1）-for循环"><a href="#（1）-for循环" class="headerlink" title="（1） for循环"></a>（1） for循环</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; myArray.length; index++) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="（2）-forEach方法遍历数组"><a href="#（2）-forEach方法遍历数组" class="headerlink" title="（2） forEach方法遍历数组"></a>（2） forEach方法遍历数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="（3）-for-in循环"><a href="#（3）-for-in循环" class="headerlink" title="（3） for-in循环"></a>（3） for-in循环</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123; <span class="comment">// 千万别这样做！！</span></span><br><span class="line">    <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这绝对是一个糟糕的选择，为什么呢？<br>    1）在这段代码中，赋给index的值不是实际的数字，而是字符串“0”、“1”、“2”，此时很可能在无意之间进行字符串算数计算，例如：“2” + 1 == “21”，这给编码过程带来极大的不便。<br>    2）作用于数组的for-in循环体除了遍历数组元素外，还会遍历自定义属性。<br>    举个例子，如果你的数组中有一个可枚举属性myArray.name，循环将额外执行一次，遍历到名为“name”的索引。就连数组原型链上的属性都能被访问到。<br>    3）最让人震惊的是，在某些情况下，这段代码可能按照随机顺序遍历数组元素。<br>    4）简而言之，for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历。 </p><h2 id="（4）强大的for-of循环"><a href="#（4）强大的for-of循环" class="headerlink" title="（4）强大的for-of循环"></a>（4）强大的for-of循环</h2><pre><code class="javascript"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> myArray) {    <span class="built_in">console</span>.log(value);}</code></pre><p>1）这是最简洁、最直接的遍历数组元素的语法；<br>2）这个方法避开了for-in循环的所有缺陷 ；<br>3）与forEach()不同的是，它可以正确响应break、continue和return语句 ；<br>4）for-of循环也可以遍历其它的集合，for-of循环不仅支持数组，还支持大多数类数组对象，例如DOM NodeList对象；<br>5）for-of循环也支持字符串遍历，它将字符串视为一系列的Unicode字符来进行遍历。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;for-of-循环&quot;&gt;&lt;a href=&quot;#for-of-循环&quot; class=&quot;headerlink&quot; title=&quot;for-of 循环&quot;&gt;&lt;/a&gt;for-of 循环&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;任何部署了Iterator接口的对象，都可以使用for-of循环遍历。
我们如何遍历数组中的元素：
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;（1）-for循环&quot;&gt;&lt;a href=&quot;#（1）-for循环&quot; class=&quot;headerlink&quot; title=&quot;（1） for循环&quot;&gt;&lt;/a&gt;（1） for循环&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; index &amp;lt; myArray.length; index++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 		&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(myArray[index]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（八）函数的扩展</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（八）函数的扩展/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-10T08:07:22.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="（1）-为函数的参数设置默认值"><a href="#（1）-为函数的参数设置默认值" class="headerlink" title="（1） 为函数的参数设置默认值"></a>（1） 为函数的参数设置默认值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span> (<span class="params">x=<span class="number">0</span>,y=<span class="number">0</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何带有默认值的参数，都被是为可选参数，不带默认值的参数，则被视为必需参数<br><a id="more"></a></p><h2 id="（2）rest参数"><a href="#（2）rest参数" class="headerlink" title="（2）rest参数"></a>（2）rest参数</h2><p>ES6引入了rest参数（…变量名），用于获取函数的多于参数，rest参数后面不能再有其他参数，否则会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">of</span> values) &#123;</span><br><span class="line">sum +=value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>);<span class="comment">//10</span></span><br></pre></td></tr></table></figure></p><h2 id="（3）扩展运算符…"><a href="#（3）扩展运算符…" class="headerlink" title="（3）扩展运算符…"></a>（3）扩展运算符…</h2><pre><code>扩展运算符好比rest参数的逆运算，将一个数组转换为用逗号分隔的参数序列。</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> b=[<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> c=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> d=[<span class="number">0</span>,...a,...b,...c];</span><br><span class="line"><span class="built_in">console</span>.log(d);<span class="comment">//[0,1,2,3,4,5,6];</span></span><br></pre></td></tr></table></figure><h2 id="（4）箭头函数-gt"><a href="#（4）箭头函数-gt" class="headerlink" title="（4）箭头函数=&gt;"></a>（4）箭头函数=&gt;</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">等同于：</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line">等同于：<span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>简化函数：</code></pre><pre><code class="javascript">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>{    <span class="keyword">return</span> x*x;    });    <span class="comment">//箭头函数写法</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span>=&gt;</span>x*x);</code></pre><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><pre><code>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象；不可以当作构造函数，即不可以使用new命令，否则报错；不可以使用arguments对象，该对象在函数体内不存在；</code></pre><h2 id="新的知识："><a href="#新的知识：" class="headerlink" title="新的知识："></a>新的知识：</h2><pre><code>1、如果箭头函数不需要参数或者需要多个参数，就是用圆括号代表参数部分    例如： var sum (num1,num2) =&gt; num1+num2;2、如果箭头函数的代码块部分多于一条语句，就要使用大括号将其括起来，并使用return语句返回3、如果箭头函数直接返回一个对象，必须在对象外面加上括号。var getTempItem = id =&gt; ({id:id,name:&quot;Temp&quot;});由于this在箭头函数中被绑定，所以不能用call（），apply（），bind（）修改this指向</code></pre><p><strong>函数的扩展图解</strong></p><p><img src="/img/es6/function.jpg" alt="函数的扩展">                </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;函数的扩展&quot;&gt;&lt;a href=&quot;#函数的扩展&quot; class=&quot;headerlink&quot; title=&quot;函数的扩展&quot;&gt;&lt;/a&gt;函数的扩展&lt;/h1&gt;&lt;h2 id=&quot;（1）-为函数的参数设置默认值&quot;&gt;&lt;a href=&quot;#（1）-为函数的参数设置默认值&quot; class=&quot;headerlink&quot; title=&quot;（1） 为函数的参数设置默认值&quot;&gt;&lt;/a&gt;（1） 为函数的参数设置默认值&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;x=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,y=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y = y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;任何带有默认值的参数，都被是为可选参数，不带默认值的参数，则被视为必需参数&lt;br&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>node系列（二）总览二</title>
    <link href="http://yoursite.com/2018/12/15/node/node%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E6%80%BB%E8%A7%88%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/12/15/node/node系列（二）总览二/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-12-28T06:20:40.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="node-js原理图"><a href="#node-js原理图" class="headerlink" title="node.js原理图"></a>node.js原理图</h2><p><img src="/img/node/node.png" alt="数值的扩展"><br><a id="more"></a></p><ul><li>单线程: 单线程的好处就是减少内存的开销,操作系统线程不在需要创建和销毁,如果某一个事情进入了,但是被I/O阻塞了.那么这个线程就阻塞了</li><li>非阻塞I/O: 不会等到I/O语句结束了,而会执行后面的语句,非阻塞I/O就能解决问题吗?比如执行A的业务,执行过程中,B的I/O回调完成了,此时怎么办??</li><li>事件机制:不管是新用户的请求,还是老用户的I/O完成,都将以事件的方式加入事件环,等待调用</li></ul><p>说是三个特点,实际上是一个特点,离开谁都不行,都玩不转<br>node.js中所有的I/O都是异步的,回调函数套用回调函数</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ul><li>管理异步动作,定时器和回调函数的机制叫做事件循环</li><li>异步的时候会压入到这个队列然后不停的读取事件,事件发生后会把对应的回调加入队列</li><li>队列按加入的顺序依次执行,由普通函数和回调函数组成</li></ul><h2 id="common-js规范"><a href="#common-js规范" class="headerlink" title="common.js规范"></a>common.js规范</h2><ul><li>一个node.js由大量的模块组成,每个Js都是一个模块</li><li>实现require方法,npm基于common.js实现了自动加载和安装依赖</li></ul><h2 id="node-js中的全局对象"><a href="#node-js中的全局对象" class="headerlink" title="node.js中的全局对象"></a>node.js中的全局对象</h2><ul><li>node.js中有一个特殊的对象,称为全局对象global,它及其其所有的属性都可以在程序的任何地方访问,<br>即全局变量</li><li>在浏览器JavaScript中通常window是全局对象,而node.js中全局对象为global<br><strong>filename  当前模块文件的绝对路径</strong>dirname 当前模块的所在目录的绝对路径</li></ul><h2 id="模块化优点"><a href="#模块化优点" class="headerlink" title="模块化优点"></a>模块化优点</h2><ul><li>增加内聚性</li><li>有助于分工合作,方便重构</li><li>提高代码质量</li></ul><h2 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h2><ul><li>定义模块</li><li>导出模块</li><li>使用模块</li></ul><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><pre><code>加载模块后会缓存,多次加载会得到同一个对象</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载http模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>) </span><br><span class="line"><span class="comment">//查看模块缓存</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">require</span>.cache)</span><br><span class="line"><span class="comment">//查看模块的绝对路径</span></span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./test.js'</span>)</span><br><span class="line"><span class="comment">//查看单个模块的缓存</span></span><br><span class="line"><span class="built_in">require</span>.cache[<span class="built_in">require</span>.resolve(<span class="string">'./test.js'</span>)]</span><br><span class="line"><span class="comment">//删除模块的缓存</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">require</span>.cache[<span class="built_in">require</span>.resolve(<span class="string">'./test.js'</span>)]</span><br><span class="line">同步方法</span><br></pre></td></tr></table></figure><h2 id="包和npm"><a href="#包和npm" class="headerlink" title="包和npm"></a>包和npm</h2><ul><li>多个模块可以封装成一个包</li><li>npm是mode.js默认的模块管理器,用于安装和管理node模块可以用包的方式通过npm安装,卸载,发布包</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;node-js原理图&quot;&gt;&lt;a href=&quot;#node-js原理图&quot; class=&quot;headerlink&quot; title=&quot;node.js原理图&quot;&gt;&lt;/a&gt;node.js原理图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/node/node.png&quot; alt=&quot;数值的扩展&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（十二）Promise</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89Promise/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（十二）Promise/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-10T08:33:11.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>ES6原生提供Promise对象。所谓Promise对象，就是代表了未来某个将要发生的事件（通常是一个异步操作）。它的好处在于，有了promise对象，就可以将异步操作的流程表达出来，避免了层层嵌套的回调函数。<br><a id="more"></a></p><h2 id="Promise对象的基本用法："><a href="#Promise对象的基本用法：" class="headerlink" title="Promise对象的基本用法："></a>Promise对象的基本用法：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="comment">/*异步操作成功*/</span>) &#123;</span><br><span class="line">resolve(value);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reject(error);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="comment">//success</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="comment">//failure</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上代码表示，Promise 构造函数接受一个函数作为参数，该函数的两个参数分别为resolve方法和reject方法。如果异步操作成功，则用resolve方法将Promise对象的状态变为成功，否则，用reject方法将状态变为失败。</p><p>promise实例生成以后，可以使用then方法分别制定resolve方法和reject方法的回调函数。<br>    用Promise对象实现Ajax操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function"><span class="keyword">function</span> (<span class="params">resolve,reject</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">client.open(<span class="string">"GET"</span>,url);</span><br><span class="line">client.onreadystatechange = handler;</span><br><span class="line">client.responseType = <span class="string">"json"</span>;</span><br><span class="line">client.setRequestHeader(<span class="string">"Accept"</span>,<span class="string">"application/json"</span>);</span><br><span class="line">client.send();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.readyState === <span class="keyword">this</span>.DONE) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">resolve(<span class="keyword">this</span>.response);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reject(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/post.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>)</span>&#123;</span><br><span class="line"><span class="comment">//continue</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line"><span class="comment">//handle errors</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="Promise-对象有三种状态："><a href="#Promise-对象有三种状态：" class="headerlink" title="Promise 对象有三种状态："></a>Promise 对象有三种状态：</h2><p>(1)Fulfilled 可以理解为成功的状态<br>(2)Rejected 可以理解为失败的状态<br>(3)Pending 既不是 Fulfilld 也不是 Rejected 的状态，可以理解为 Promise 对象实例创建时候的初始状态</p><p>Promise.all 可以接收一个元素为 Promise 对象的数组作为参数，当这个数组里面所有的 Promise 对象都变为 resolve 时，该方法才会返回。</p><p><strong>Promise图解</strong></p><p><img src="/img/es6/promise.jpg" alt="Promise"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h1&gt;&lt;p&gt;ES6原生提供Promise对象。所谓Promise对象，就是代表了未来某个将要发生的事件（通常是一个异步操作）。它的好处在于，有了promise对象，就可以将异步操作的流程表达出来，避免了层层嵌套的回调函数。&lt;br&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（五）字符串的扩展</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（五）字符串的扩展/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-17T03:56:29.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><h2 id="1-、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中："><a href="#1-、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中：" class="headerlink" title="1)、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中："></a>1)、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中：</h2><pre><code>（1）contains():返回布尔值，表示是否找到了参数字符串（2）startsWith():返回布尔值，表示参数字符串是否在源字符串的头部（3）endsWith():返回布尔值，表示参数字符串是否在源字符串的尾部</code></pre><a id="more"></a>        <pre><code>例如：</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"Hello world!"</span>;</span><br><span class="line">s.startsWith(<span class="string">"Hell"</span>);<span class="comment">//true</span></span><br><span class="line">s.endsWith(<span class="string">"!"</span>);<span class="comment">//true</span></span><br><span class="line">s.contains(<span class="string">"o"</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><pre><code>以上三个函数都支持第二个参数，表示开始搜索的位置</code></pre><pre><code class="javascript">s.startsWith(<span class="string">"o"</span>,<span class="number">4</span>);<span class="comment">//true</span>s.endsWith(<span class="string">"e"</span>,<span class="number">2</span>);<span class="comment">//true</span></code></pre><h2 id="2）repeat"><a href="#2）repeat" class="headerlink" title="2）repeat()"></a>2）repeat()</h2><pre><code>返回一个新的字符串，表示将原字符串重复n次</code></pre><pre><code class="javascript"><span class="string">"x"</span>.repeat(<span class="number">3</span>);<span class="comment">//"xxx"</span></code></pre><h2 id="3-模板字符串"><a href="#3-模板字符串" class="headerlink" title="3) 模板字符串"></a>3) 模板字符串</h2><p>1.模板字符串是增强版的字符串，用反引号（`）标识。<br>2.它可以当作普通字符串使用，可以用来定义多行字符串，或者在字符串中嵌入变量</p><pre><code class="javascript"><span class="comment">//普通字符串</span><span class="string">`Hello World`</span>;<span class="comment">//多行字符串</span><span class="string">`Hello</span><span class="string">World!`</span><span class="comment">//字符串中嵌入变量</span><span class="keyword">var</span> name = <span class="string">'Bob'</span>,time = <span class="string">"today"</span>;<span class="string">`Hello <span class="subst">${name}</span>,how are you <span class="subst">${time}</span>?`</span>;</code></pre><pre><code>在模板字符串中嵌入变量，需要将变量名写在${}中。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;字符串的扩展&quot;&gt;&lt;a href=&quot;#字符串的扩展&quot; class=&quot;headerlink&quot; title=&quot;字符串的扩展&quot;&gt;&lt;/a&gt;字符串的扩展&lt;/h1&gt;&lt;h2 id=&quot;1-、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中：&quot;&gt;&lt;a href=&quot;#1-、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中：&quot; class=&quot;headerlink&quot; title=&quot;1)、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中：&quot;&gt;&lt;/a&gt;1)、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;（1）contains():返回布尔值，表示是否找到了参数字符串
（2）startsWith():返回布尔值，表示参数字符串是否在源字符串的头部
（3）endsWith():返回布尔值，表示参数字符串是否在源字符串的尾部
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（二） const命令</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%20const%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（二） const命令/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-17T03:54:31.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h1><pre><code>const用来声明常量，一旦声明，其值就不能改变。const与let的作用域相同，只在声明所在的块级作用域内有效。const声明的常量不可重复声明</code></pre><p><strong>const命令图解</strong></p><p><img src="/img/es6/const.jpg" alt="const命令"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;const命令&quot;&gt;&lt;a href=&quot;#const命令&quot; class=&quot;headerlink&quot; title=&quot;const命令&quot;&gt;&lt;/a&gt;const命令&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;const用来声明常量，一旦声明，其值就不能改变。
const与let的作用域相同，
      
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
</feed>
