<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qihui</title>
  
  <subtitle>倘只看书，便变成书橱</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-15T14:31:03.704Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>齐辉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java-- String是关键字吗???</title>
    <link href="http://yoursite.com/2018/12/15/java/java--%20String%E6%98%AF%E5%85%B3%E9%94%AE%E5%AD%97%E5%90%97___/"/>
    <id>http://yoursite.com/2018/12/15/java/java-- String是关键字吗___/</id>
    <published>2018-12-15T14:26:40.041Z</published>
    <updated>2018-12-15T14:31:03.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="String是关键字吗"><a href="#String是关键字吗" class="headerlink" title="String是关键字吗???"></a>String是关键字吗???</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helloword</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>这是学java基本都会写一个例子,这里我们可以探讨几个概念性的问题,String 是关键字（keyword）吗？ <ul><li>要弄清这个问题,首先我们的了解什么是String?<br>String是一个类名，即Class java.lang.String 的类名，也就是常说的字符串类，其对象就是字符串。 </li><li>那什么又是关键字呢?<br>关键字是电脑语言里事先定义的,有特别意义的标识符,有时又叫保留字，还有特别意义的变量。 Java的关键字对java的编译器有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等，关键字不能用作变量名、方法名、类名、包名。 </li></ul></li></ul><p>==既然关键字不能用作类名，那么用作类名的就不是关键字，所以，String不是关键字.==</p><p>这里我们还可以引申另一个知识<strong>标识符</strong>,这也是一个容易与关键弄混的概念</p><ul><li>标识符（identifier)<br>  是指类名(包括接口、枚举、抽象类)、方法名、变量、常量名、包名等可以自定义的字符组合。<br>  虽然可以自定义，但是也要遵循如下规则：<br>  由字母, 下划线, 数字, $符号组成;<br>  只能以字母、下划线、$符号开头，不能以数字开头；<br>  标识符长度没有限;<br>  区分大小写<br>  不能是关键字</li></ul><p><strong>因此我们可以得出一个结论:</strong><br>==String 是Java基础库中的一个常用类的类名，属于标识符(identifier)，不是关键字==</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;String是关键字吗&quot;&gt;&lt;a href=&quot;#String是关键字吗&quot; class=&quot;headerlink&quot; title=&quot;String是关键字吗???&quot;&gt;&lt;/a&gt;String是关键字吗???&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Helloword&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello world&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java Thinking" scheme="http://yoursite.com/tags/java-Thinking/"/>
    
  </entry>
  
  <entry>
    <title>java基础--常用关键字</title>
    <link href="http://yoursite.com/2018/12/15/java/java%E5%9F%BA%E7%A1%80_%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2018/12/15/java/java基础_常用关键字/</id>
    <published>2018-12-15T13:03:42.225Z</published>
    <updated>2018-12-15T13:32:41.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><ul><li><p>基本类型</p><pre><code>整数    byte short int long小数    float double字符    char布尔类型(boolean)    true false</code></pre></li><li><p>访问控制</p><pre><code>public protected private </code></pre></li><li><p>程序控制</p><pre><code>break    continue    return    do    while    if    else    for    instanceof    switch   case    default</code></pre></li><li><p>类,方法以及变量修饰符</p><pre><code>class abstract final    extends static    new  implementsnative    strictfp    synchronized    transient    volatile</code></pre></li><li><p>异常处理</p><pre><code>try catch throw throws</code></pre></li><li><p>包相关的</p><pre><code>import package</code></pre></li><li><p>变量引用</p><pre><code>this super void</code></pre></li><li><p>保留字</p><pre><code>goto const</code></pre></li></ul><a id="more"></a><h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><ul><li><p>整数</p><pre><code>byte: 字节型short: 短整型int: 整型long; 长整型    都是java的原始数据类型    byte为8个字节,可以储存 [-128,127]范围以内的整数值    short为16个字节,可以存储 16 位带符号的整数.    int为32个字节,可以存储 32 位带符号的整数.    long为64个字节,可以存储 64 位带符号的整数.(-2^63至2^63-1)    包装对象类        byte: Byte        short: Short        int: Integer        long: Long        表示原始类型的包装对象类.它定义代表此类型值的范为:MIN_VALUE和MAX_VALUE常量java中所有的整数值都是32的int值,除非值后面有 l 或 L（如 235L），这表示该值应解释为 long。</code></pre></li></ul><ul><li><p>小数</p><pre><code>float: 浮点double: 双精度    都是java原始数据类型    float变量可以储存单精度福浮点值    double变量可以储存双精度的浮点值注意:    由于java默认的浮点为双精度,因此要指定单精度文字(即用float),    应在后面加上f,F.如: 0.11f由于浮点数据类型是实际数值的近视值,因此,一般不要对浮点数值进行相等的比较java中的浮点数值可以代表无穷大和NAN(非数值).Float和Double包装对象类用来定义常量 MIN_VALUE、MAX_VALUE、NEGATIVE_INFINITY、POSITIVE_INFINITY 和 NaN。</code></pre></li><li><p>字符</p><pre><code>char 是 Java 原始类型。char 变量可以存储一个 Unicode 字符。 可以使用下列 char 常量：    \b - 空格     \f - 换页    \n - 换行    \r - 回车    \t - 水平制表符     \&apos; - 单引号    \&quot; - 双引号    \\ - 反斜杠    \xxx - 采用 xxx 编码的 Latin-1 字符    \x 和 \xx 均为合法形式，但可能引起混淆    \uxxxx - 采用十六进制编码 xxxx 的 Unicode 字符Character 类包含一些可用来处理 char 变量的 static 方法，这些方法包括 isDigit()、isLetter()、isWhitespace() 和 toUpperCase()。</code></pre></li><li><p>布尔值(boolean)</p><pre><code>ture false对,错boolean 变量的两个合法值</code></pre></li></ul><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><ul><li><p>public    公共的</p><pre><code>public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用</code></pre></li><li><p>protected</p><pre><code>  对同一包内的类和所有子类可见。使用对象：变量、方法.  protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。  主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西</code></pre></li><li><p>private 私有的</p><pre><code>  private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用  访问权限仅限于类的内部，是一种封装的体现，例如，大多数成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问</code></pre></li></ul><h4 id="类-方法以及变量修饰符"><a href="#类-方法以及变量修饰符" class="headerlink" title="类,方法以及变量修饰符"></a>类,方法以及变量修饰符</h4><ul><li><p>class 类</p><pre><code>  class 关键字是用来声明新的 java 类的,该类是相关变量或方法的集合.  类是面向对象的程序设计方法的基本构造单位.  类通常代表某种实际实体.如几何形状或人.类是对象的模板.每个对象都是类的一个实例.要使用类,通常使用  new 操作符将类的对象实例化,然后调用类的方法来访问类的功能</code></pre></li><li><p>abstract  抽象类</p><pre><code>  在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，  如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。  由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</code></pre></li><li><p>final 最终的</p><pre><code>  final关键字可以用于声明属性,方法和类  用于类,表示类不可以扩展(不能呢有子类)  用于方法,表示在子类中不可以重写此方法.注意:    一个类不可以同时是abstract又是final.abstract意味着必须扩展类,    final则不能扩展.    一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，    final 则不能重写方法</code></pre></li><li><p>extends 继承、扩展</p><pre><code>extends关键字用在class或interface声明中,用于指示所声明的类或接口时其名称后跟有extends关键字的类或接口的子类.子类继承父类的所有的public和protected变量和方法. 子类可以重写父类的任何final方法.一个类自能扩展一个其他的类.        </code></pre></li><li><p>static 静态</p><pre><code>  static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）。   通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。static（内部）类可以被其他类实例化和引用（即使它是顶级类）。在上面的示例中，另一个类中的代码可以实例化 MyStaticClass 类，方法是用包含它的类名来限定其名称，如 MyClass.MyStaticClass。   static 字段（类的成员变量）在类的所有实例中只存在一次。 可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。  模式：public final static &lt;type&gt; varName = &lt;value&gt;; 通常用于声明可以在类的外部使用的类常量。在引用这样的类常量时需要用类名加以限定。在上面的示例中，另一个类可以用 MyClass.MAX_OBJECTS 形式来引用 MAX_OBJECTS 常量</code></pre></li><li><p>new</p><pre><code>new关键字用于创建类的新实例new关键字后面的参数必须是类名,并且类名的后面必须是一组构造方法参数(必须带括号)参数集合必须与类的构造方法签名匹配左侧的变量的类型必须与要实例化的类或接口具有赋值兼容关系</code></pre></li><li><p>interface</p><pre><code>interface 关键字是用来声明新的java接口,接口时方法的集合.接口是java语言的一项强大的功能.任何类都可声明它实现一个或多个接口,这意味着它实现了这些接口中所定义的所有方法实现了接口的任何类都必须提供在该接口中的所有方法实现.一个类可以实现多个接口</code></pre></li><li><p>implements</p><pre><code>implements关键字在class声明中使用,声明类提供了implements 关键字后面名称所指定接口所声明的所有方法.类必须实现接口的中所有方法.一个类可以实现多个接口.</code></pre><h4 id="包相关"><a href="#包相关" class="headerlink" title="包相关"></a>包相关</h4></li><li><p>import 引入</p><pre><code>import 关键字使一个包中的一个或所有类在当前 Java 源文件中可见。可以不使用完全限定的类名来引用导入的类。 当多个包包含同名的类时，许多 Java 程序员只使用特定的 import 语句（没有“*”）来避免不确定性。</code></pre></li><li><p>package 包</p><pre><code>package 关键字指定在 Java 源文件中声明的类所驻留的 Java 包。 package 语句（如果出现）必须是 Java 源文件中的第一个非注释性文本。 </code></pre><p>  例:java.lang.Object。<br>  如果 Java 源文件不包含 package 语句，在该文件中定义的类将位于“默认包”中。<br>  请注意，不能从非默认包中的类引用默认包中的类。</p><h4 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h4></li><li><p>this</p><pre><code>this 关键字用于引用当前实例。 当引用可能不明确时，可以使用 this 关键字来引用当前的实例。</code></pre></li><li><p>void 无返回值</p><pre><code>void 关键字表示 null 类型。 void 可以用作方法的返回类型，以指示该方法不返回值。</code></pre></li><li><p>super</p><pre><code>  super 关键字用于引用使用该关键字的类的超类。 作为独立语句出现的 super 表示调用超类的构造方法。   super.&lt;methodName&gt;() 表示调用超类的方法。只有在如下情况中才需要采用这种用法：要调用在该类中被重写的方法，以便指定应当调用在超类中的该方法。</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基本类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;整数
    byte short int long
小数
    float double
字符
    char
布尔类型(boolean)
    true false
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;访问控制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public protected private 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;程序控制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;break    continue    return    do    
while    if    else    for    instanceof    
switch   case    default
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类,方法以及变量修饰符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class abstract final    extends static    new  implements
native    strictfp    synchronized    transient    volatile
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;异常处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try catch throw throws
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;包相关的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import package
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;变量引用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this super void
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;保留字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;goto const
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>node系列（一）总览一</title>
    <link href="http://yoursite.com/2018/12/15/node/node%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E6%80%BB%E8%A7%88%E4%B8%80/"/>
    <id>http://yoursite.com/2018/12/15/node/node系列（一）总览一/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-12-24T10:46:17.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是node"><a href="#什么是node" class="headerlink" title="什么是node?"></a>什么是node?</h2><ul><li>Node.js是一个让JS可以运行在浏览器之外的服务器端的平台</li><li>它实现了诸如文件系统、模块、包、操作系统API，网络通信等核心 JS没有或不完善的功能</li><li>它摒弃传统平台依赖多线程来实现高并发的设计思路，而采用单线程，异步式I/O，事件驱动式的程序设计模型</li><li>Node.js使用了来自Google ChromeV8引擎。V8是目前世界上最快的javascript引擎<a id="more"></a></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>所谓特点,就是node.js如何解决服务器高性能瓶颈问题的</li></ul><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><ul><li>在java,php或者.net等服务器语言中,会为客户端创建一个新的线程,而每一个线程需要消耗2mb内存.理论上,一个8GB的服务器可以同时连接最大用户为4000个左右.要让web应用程序支持更多的用户,就需要增加服务器的数量,而web应用程序的硬件成本当然也就上升了</li><li>node.js不为每一个用户创建一个新的线程,而仅仅使用一个线程.当有用户连接了,就会触发一个内部事件,通过非阻塞I/O,事件驱动机制,让node.js程序宏观上也是并行的,使用node.js,一个8GB内存的服务器,可以同时处理超过4万用户的连接</li><li>另外,单线程带来的好处就是减少内存的开销,还有操作系统完全不再有线程创建、销毁的时间开销。</li><li>坏处,就是一个用户造成的线程的崩溃,整个服务器都崩溃了,其他的人也就都崩溃了</li></ul><h3 id="非阻塞I-O-non-blocking-I-O"><a href="#非阻塞I-O-non-blocking-I-O" class="headerlink" title="非阻塞I/O  non-blocking I/O"></a>非阻塞I/O  non-blocking I/O</h3><ul><li>例如,当在访问数据库取得数据的时候,需要一段时间.当传统的单线程处理机制中,在执行了访问数据库代码之后,整个线程都将暂停下来,等待数据库返回结果,才能执行后面的代码.也就是说,I/O阻塞了代码的执行,极大的降低了程序的执行效率</li><li>由于node.js中采用了非阻塞I/O机制,因此在执行访问数据库的代码,将立即执行其他后面的代码,把数据库返回结果的处理代码放在回调函数中,从而提高了程序的执行效率.</li><li>当某个I/O执行完毕时,将以事件的形式通知执行I/O操作的线程,线程执行的这个事件的回调函数.为了处理异步I/O,线程必须有事件循环,不断的检查有没有未处理的事件,一次予以处理.</li><li>阻塞模式下,一个线程只能处理一项任务,想要提高吞吐量,必须通过多线程.而非阻塞I/O模式下,一个线程永远在执行计算操作,这个线程的CPU核心利用率永远是100%</li></ul><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><ul><li>在node.js中,客户端请求建立连接,提交数据等行为会出触发相应的事件.在node中,一个时刻只能执行一个事件的回调函数,但是在执行一个事件回调函数的中途,可以转而处理其他的事情(比如,又有新用户连接了),然后返回执行原事件的回调函数,这种处理的机制,称为”事件环”机制</li><li>mode.js底层是c++写的(V8也是用C++写的).底层代码中,近半数都是用于事件队列,回调函数队列的构建.用事件驱动来完成服务的任务调用</li></ul><h2 id="node-js的优点"><a href="#node-js的优点" class="headerlink" title="node.js的优点"></a>node.js的优点</h2><pre><code>·Nodejs基于Javascript语言·统一公共类库，代码标准化·Nodejs选择了目前最快的浏览器内核V8作为执行引擎·Nodejs的社区非常活跃 www.npmjs.com</code></pre><h2 id="适用开发"><a href="#适用开发" class="headerlink" title="适用开发"></a>适用开发</h2><ul><li>node.js适用于开发什么样的应用程序?<ul><li>善用于I/O,不善于计算.因为node.js最擅长的就是任务调用.如果的你的业务有很多的CPU计算,实际上也相当于这个计算阻塞了这个单线程,就不适合node开发.<br>当应用程序需要处理大量并发的I/O,而在向客户端发出响应之前,应用程序内部并不需要进行复杂的处理时候,node.js非常合适,node.js也非常适合与web socket配合,开发长连接的实时交互应用程序.<ul><li>比如<ul><li>用户表单的收集</li><li>聊天室</li><li>图文直播</li><li>提供JSON的API</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是node&quot;&gt;&lt;a href=&quot;#什么是node&quot; class=&quot;headerlink&quot; title=&quot;什么是node?&quot;&gt;&lt;/a&gt;什么是node?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Node.js是一个让JS可以运行在浏览器之外的服务器端的平台&lt;/li&gt;
&lt;li&gt;它实现了诸如文件系统、模块、包、操作系统API，网络通信等核心 JS没有或不完善的功能&lt;/li&gt;
&lt;li&gt;它摒弃传统平台依赖多线程来实现高并发的设计思路，而采用单线程，异步式I/O，事件驱动式的程序设计模型&lt;/li&gt;
&lt;li&gt;Node.js使用了来自Google ChromeV8引擎。V8是目前世界上最快的javascript引擎
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>node系列（二）总览二</title>
    <link href="http://yoursite.com/2018/12/15/node/node%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E6%80%BB%E8%A7%88%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/12/15/node/node系列（二）总览二/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-12-28T06:20:40.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="node-js原理图"><a href="#node-js原理图" class="headerlink" title="node.js原理图"></a>node.js原理图</h2><p><img src="/img/node/node.png" alt="数值的扩展"><br><a id="more"></a></p><ul><li>单线程: 单线程的好处就是减少内存的开销,操作系统线程不在需要创建和销毁,如果某一个事情进入了,但是被I/O阻塞了.那么这个线程就阻塞了</li><li>非阻塞I/O: 不会等到I/O语句结束了,而会执行后面的语句,非阻塞I/O就能解决问题吗?比如执行A的业务,执行过程中,B的I/O回调完成了,此时怎么办??</li><li>事件机制:不管是新用户的请求,还是老用户的I/O完成,都将以事件的方式加入事件环,等待调用</li></ul><p>说是三个特点,实际上是一个特点,离开谁都不行,都玩不转<br>node.js中所有的I/O都是异步的,回调函数套用回调函数</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ul><li>管理异步动作,定时器和回调函数的机制叫做事件循环</li><li>异步的时候会压入到这个队列然后不停的读取事件,事件发生后会把对应的回调加入队列</li><li>队列按加入的顺序依次执行,由普通函数和回调函数组成</li></ul><h2 id="common-js规范"><a href="#common-js规范" class="headerlink" title="common.js规范"></a>common.js规范</h2><ul><li>一个node.js由大量的模块组成,每个Js都是一个模块</li><li>实现require方法,npm基于common.js实现了自动加载和安装依赖</li></ul><h2 id="node-js中的全局对象"><a href="#node-js中的全局对象" class="headerlink" title="node.js中的全局对象"></a>node.js中的全局对象</h2><ul><li>node.js中有一个特殊的对象,称为全局对象global,它及其其所有的属性都可以在程序的任何地方访问,<br>即全局变量</li><li>在浏览器JavaScript中通常window是全局对象,而node.js中全局对象为global<br><strong>filename  当前模块文件的绝对路径</strong>dirname 当前模块的所在目录的绝对路径</li></ul><h2 id="模块化优点"><a href="#模块化优点" class="headerlink" title="模块化优点"></a>模块化优点</h2><ul><li>增加内聚性</li><li>有助于分工合作,方便重构</li><li>提高代码质量</li></ul><h2 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h2><ul><li>定义模块</li><li>导出模块</li><li>使用模块</li></ul><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><pre><code>加载模块后会缓存,多次加载会得到同一个对象</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载http模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>) </span><br><span class="line"><span class="comment">//查看模块缓存</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">require</span>.cache)</span><br><span class="line"><span class="comment">//查看模块的绝对路径</span></span><br><span class="line"><span class="built_in">require</span>.resolve(<span class="string">'./test.js'</span>)</span><br><span class="line"><span class="comment">//查看单个模块的缓存</span></span><br><span class="line"><span class="built_in">require</span>.cache[<span class="built_in">require</span>.resolve(<span class="string">'./test.js'</span>)]</span><br><span class="line"><span class="comment">//删除模块的缓存</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">require</span>.cache[<span class="built_in">require</span>.resolve(<span class="string">'./test.js'</span>)]</span><br><span class="line">同步方法</span><br></pre></td></tr></table></figure><h2 id="包和npm"><a href="#包和npm" class="headerlink" title="包和npm"></a>包和npm</h2><ul><li>多个模块可以封装成一个包</li><li>npm是mode.js默认的模块管理器,用于安装和管理node模块可以用包的方式通过npm安装,卸载,发布包</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;node-js原理图&quot;&gt;&lt;a href=&quot;#node-js原理图&quot; class=&quot;headerlink&quot; title=&quot;node.js原理图&quot;&gt;&lt;/a&gt;node.js原理图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/node/node.png&quot; alt=&quot;数值的扩展&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（十）Iterator遍历器</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%EF%BC%89Iterator%E9%81%8D%E5%8E%86%E5%99%A8/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（十）Iterator遍历器/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-10T08:20:33.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Iterator遍历器"><a href="#Iterator遍历器" class="headerlink" title="Iterator遍历器"></a>Iterator遍历器</h1><p>遍历器是一种协议，任何对象只要部署了这个协议，就可以完成遍历操作。它的主要作用有两个<br>&nbsp;&nbsp;1.一个是为遍历对象的属性提供统一的接口，<br>&nbsp;&nbsp;2.二是时对象的属性能够按次序排列。</p><p>ES6的遍历器协议规定，部署了next方法的对象，就具备了遍历器功能。<br>&nbsp;&nbsp;next方法必须返回一个包含value和done两个属性的对象。<br>&nbsp;&nbsp;value属性是当前遍历位置的值，<br>&nbsp;&nbsp;done属性是一个布尔值，表似乎遍历是否结束。<br><a id="more"></a>        </p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span> (<span class="params">array</span>) </span>{    <span class="keyword">var</span> nextIndex = <span class="number">0</span>;    <span class="keyword">return</span> {        next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{            <span class="keyword">return</span> nextIndex &lt; array.length ? {<span class="attr">value</span>:array[nextIndex++],<span class="attr">done</span>:<span class="literal">false</span>}:{<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>};        }    }}    <span class="comment">//定义了一个makeIterator函数，作用是返回一个遍历器对象，用来遍历参数数组。</span></code></pre><pre><code>ES6中，一个对象只要部署了next方法，就被视为具有Iterator接口，就可以用for...of循环遍历它的值。</code></pre><pre><code class="javascript"><span class="keyword">var</span> it = makeIterator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);<span class="keyword">for</span>(<span class="keyword">var</span> n <span class="keyword">of</span> it) {    <span class="keyword">if</span>(n&gt;it.length){        <span class="keyword">break</span>;    }    <span class="built_in">console</span>.log(n);}</code></pre><pre><code>for...in 循环读取键名；for...of循环读取键值</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Iterator遍历器&quot;&gt;&lt;a href=&quot;#Iterator遍历器&quot; class=&quot;headerlink&quot; title=&quot;Iterator遍历器&quot;&gt;&lt;/a&gt;Iterator遍历器&lt;/h1&gt;&lt;p&gt;遍历器是一种协议，任何对象只要部署了这个协议，就可以完成遍历操作。它的主要作用有两个&lt;br&gt;&amp;nbsp;&amp;nbsp;1.一个是为遍历对象的属性提供统一的接口，&lt;br&gt;&amp;nbsp;&amp;nbsp;2.二是时对象的属性能够按次序排列。&lt;/p&gt;
&lt;p&gt;ES6的遍历器协议规定，部署了next方法的对象，就具备了遍历器功能。&lt;br&gt;&amp;nbsp;&amp;nbsp;next方法必须返回一个包含value和done两个属性的对象。&lt;br&gt;&amp;nbsp;&amp;nbsp;value属性是当前遍历位置的值，&lt;br&gt;&amp;nbsp;&amp;nbsp;done属性是一个布尔值，表似乎遍历是否结束。&lt;br&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（五）字符串的扩展</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（五）字符串的扩展/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-17T03:56:29.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><h2 id="1-、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中："><a href="#1-、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中：" class="headerlink" title="1)、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中："></a>1)、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中：</h2><pre><code>（1）contains():返回布尔值，表示是否找到了参数字符串（2）startsWith():返回布尔值，表示参数字符串是否在源字符串的头部（3）endsWith():返回布尔值，表示参数字符串是否在源字符串的尾部</code></pre><a id="more"></a>        <pre><code>例如：</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"Hello world!"</span>;</span><br><span class="line">s.startsWith(<span class="string">"Hell"</span>);<span class="comment">//true</span></span><br><span class="line">s.endsWith(<span class="string">"!"</span>);<span class="comment">//true</span></span><br><span class="line">s.contains(<span class="string">"o"</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><pre><code>以上三个函数都支持第二个参数，表示开始搜索的位置</code></pre><pre><code class="javascript">s.startsWith(<span class="string">"o"</span>,<span class="number">4</span>);<span class="comment">//true</span>s.endsWith(<span class="string">"e"</span>,<span class="number">2</span>);<span class="comment">//true</span></code></pre><h2 id="2）repeat"><a href="#2）repeat" class="headerlink" title="2）repeat()"></a>2）repeat()</h2><pre><code>返回一个新的字符串，表示将原字符串重复n次</code></pre><pre><code class="javascript"><span class="string">"x"</span>.repeat(<span class="number">3</span>);<span class="comment">//"xxx"</span></code></pre><h2 id="3-模板字符串"><a href="#3-模板字符串" class="headerlink" title="3) 模板字符串"></a>3) 模板字符串</h2><p>1.模板字符串是增强版的字符串，用反引号（`）标识。<br>2.它可以当作普通字符串使用，可以用来定义多行字符串，或者在字符串中嵌入变量</p><pre><code class="javascript"><span class="comment">//普通字符串</span><span class="string">`Hello World`</span>;<span class="comment">//多行字符串</span><span class="string">`Hello</span><span class="string">World!`</span><span class="comment">//字符串中嵌入变量</span><span class="keyword">var</span> name = <span class="string">'Bob'</span>,time = <span class="string">"today"</span>;<span class="string">`Hello <span class="subst">${name}</span>,how are you <span class="subst">${time}</span>?`</span>;</code></pre><pre><code>在模板字符串中嵌入变量，需要将变量名写在${}中。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;字符串的扩展&quot;&gt;&lt;a href=&quot;#字符串的扩展&quot; class=&quot;headerlink&quot; title=&quot;字符串的扩展&quot;&gt;&lt;/a&gt;字符串的扩展&lt;/h1&gt;&lt;h2 id=&quot;1-、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中：&quot;&gt;&lt;a href=&quot;#1-、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中：&quot; class=&quot;headerlink&quot; title=&quot;1)、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中：&quot;&gt;&lt;/a&gt;1)、ES6提供了3中新方法来确定一个字符串是否包含在另一个字符串中：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;（1）contains():返回布尔值，表示是否找到了参数字符串
（2）startsWith():返回布尔值，表示参数字符串是否在源字符串的头部
（3）endsWith():返回布尔值，表示参数字符串是否在源字符串的尾部
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（四） for-of 循环</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%20for-of%20%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（四） for-of 循环/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-17T03:56:36.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for-of 循环"></a>for-of 循环</h1><pre><code>任何部署了Iterator接口的对象，都可以使用for-of循环遍历。我们如何遍历数组中的元素：</code></pre><h2 id="（1）-for循环"><a href="#（1）-for循环" class="headerlink" title="（1） for循环"></a>（1） for循环</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; myArray.length; index++) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="（2）-forEach方法遍历数组"><a href="#（2）-forEach方法遍历数组" class="headerlink" title="（2） forEach方法遍历数组"></a>（2） forEach方法遍历数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="（3）-for-in循环"><a href="#（3）-for-in循环" class="headerlink" title="（3） for-in循环"></a>（3） for-in循环</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123; <span class="comment">// 千万别这样做！！</span></span><br><span class="line">    <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这绝对是一个糟糕的选择，为什么呢？<br>    1）在这段代码中，赋给index的值不是实际的数字，而是字符串“0”、“1”、“2”，此时很可能在无意之间进行字符串算数计算，例如：“2” + 1 == “21”，这给编码过程带来极大的不便。<br>    2）作用于数组的for-in循环体除了遍历数组元素外，还会遍历自定义属性。<br>    举个例子，如果你的数组中有一个可枚举属性myArray.name，循环将额外执行一次，遍历到名为“name”的索引。就连数组原型链上的属性都能被访问到。<br>    3）最让人震惊的是，在某些情况下，这段代码可能按照随机顺序遍历数组元素。<br>    4）简而言之，for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历。 </p><h2 id="（4）强大的for-of循环"><a href="#（4）强大的for-of循环" class="headerlink" title="（4）强大的for-of循环"></a>（4）强大的for-of循环</h2><pre><code class="javascript"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> myArray) {    <span class="built_in">console</span>.log(value);}</code></pre><p>1）这是最简洁、最直接的遍历数组元素的语法；<br>2）这个方法避开了for-in循环的所有缺陷 ；<br>3）与forEach()不同的是，它可以正确响应break、continue和return语句 ；<br>4）for-of循环也可以遍历其它的集合，for-of循环不仅支持数组，还支持大多数类数组对象，例如DOM NodeList对象；<br>5）for-of循环也支持字符串遍历，它将字符串视为一系列的Unicode字符来进行遍历。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;for-of-循环&quot;&gt;&lt;a href=&quot;#for-of-循环&quot; class=&quot;headerlink&quot; title=&quot;for-of 循环&quot;&gt;&lt;/a&gt;for-of 循环&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;任何部署了Iterator接口的对象，都可以使用for-of循环遍历。
我们如何遍历数组中的元素：
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;（1）-for循环&quot;&gt;&lt;a href=&quot;#（1）-for循环&quot; class=&quot;headerlink&quot; title=&quot;（1） for循环&quot;&gt;&lt;/a&gt;（1） for循环&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; index &amp;lt; myArray.length; index++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 		&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(myArray[index]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>node系列（三）http</title>
    <link href="http://yoursite.com/2018/12/15/node/node%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89)http/"/>
    <id>http://yoursite.com/2018/12/15/node/node系列（三)http/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-12-28T06:21:47.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><ul><li>node.js提供了HTTP模块,其中封装了一个高效的HTTP服务器和一个简易的HTTP客户端</li><li>http.Server是一个基于事件的HTTP服务器,核心是由node.js下层C++实现的,接口是由JavaScript封装的</li><li>http.request是http客户端工具,用于客户端发送请求<a id="more"></a></li></ul><h2 id="http服务端"><a href="#http服务端" class="headerlink" title="http服务端"></a>http服务端</h2><p>http.createServer创建了http.server实例,请求对象req,响应对象res,响应代码200表示请求成功<br>http.server提供了几个事件</p><ul><li>request:当客户端请求到来时, 该事件被触发,提供了两个参数req,res分别是http.ServerRequest,http.ServerResponse表示请求和响应信息</li><li>connection: 当TCP连接建立，该事件被触发，提供了一个参数socket，为net.socket实例.connection事件的粒度要大于request，因为客户端在Keep-Alive模式下可能在同一个连接内发送多次请求</li><li><p>close: 当服务器被关闭时,事件被触发</p></li><li><p>server.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载http模块</span></span><br><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>)</span><br><span class="line"><span class="comment">//创建http服务器</span></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//向请求的客户端发送响应头,http状态值: 200 : ok,内容类型</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>,&#123;<span class="string">"Content-Type"</span>:<span class="string">"text/html;charset=UTF8"</span>&#125;)</span><br><span class="line">    <span class="comment">//向请求的客户端发送响应内容(在response.end之前，可以多次调用)</span></span><br><span class="line">    res.write(<span class="string">"你好,世界"</span>)</span><br><span class="line"><span class="comment">//响应结束，告知客户端所有的发送已经完成，</span></span><br><span class="line"><span class="comment">//如果不调用改函数，客户端将处于等待状态</span></span><br><span class="line">    res.end()</span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line">&#125;).listen(<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//终端打印信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Server Runing at http//127.0.0.1:3000/, 成功"</span>)</span><br></pre></td></tr></table></figure></li></ul><p>上述代码通过require(“http”)创建一个http实例,然后使用createServer创建一个服务器,用listen监听3000端口<br>http.ServerRequest是HTTP请求的信息，是后端开发者最关注的内容<br>HTTP请求一般分为：请求头(Request Header)请求体(Request Body)</p><ul><li>http.ServerRequest提供了三个事件用于控制请求体传输<ul><li>data:请求数据到来之后该事件被触发，事件提供了一个参数chunk，表示接收到的数据，如果该事件没有被监听, 那么请求体将会被抛弃 (可能会被多次调用)</li><li>end:当请求体数据传输完成时，事件被触发，此后不再有数据到来</li><li>close:用户当前请求结束，该事件被触发，不同于end，用户强制终止传输，也还是调用close</li></ul></li></ul><h2 id="http客户端"><a href="#http客户端" class="headerlink" title="http客户端"></a>http客户端</h2><p>http模块提供了两个函数http.request和http.get,功能是作为客户端向HTTP服务器发起请求</p><h3 id="http-request"><a href="#http-request" class="headerlink" title="http.request"></a>http.request</h3><ul><li><p>client.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="comment">//请求选项</span></span><br><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">port: <span class="string">'3000'</span>,</span><br><span class="line">path: <span class="string">'/'</span>,</span><br><span class="line">method: <span class="string">'GET'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> req = http.request(options, (res)=&gt;&#123;</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line">res.on(<span class="string">'data'</span>, (data)=&gt;&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">res.end()</span><br></pre></td></tr></table></figure><p>  我们创建了一个http请求,为响应的事件添加了data事件,最后使用了res.end()初始化和发送我们的请求<br>http.request(option,callback) 发起HTTP请求，option=》关联数组 参数：</p></li><li>host:请求网站的域名或IP地址</li><li>port:请求网站的端口，默认80</li><li>method:请求方法，默认GET</li><li>path:请求的相对于根的路径</li><li>headers:一个关联数组对象，为请求头的内容</li><li>callback:传递一个参数，为http.ClientResponse实例</li><li>http.request返回一个http.ClientRequest的实例</li></ul><h3 id="http-get"><a href="#http-get" class="headerlink" title="http.get"></a>http.get</h3><p>http.get(options,callback)是http.request的简化版，唯一的区别就是http.get自动将请求的方法设为Get请求<br>同时不需要调用req.end()<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> opts = &#123;</span><br><span class="line">　　host: <span class="string">'www.google.com'</span></span><br><span class="line">　　port: <span class="number">80</span>,</span><br><span class="line">　　path: <span class="string">'/'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> req = http.get(opts, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">　　<span class="built_in">console</span>.log(res);</span><br><span class="line">　　res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">　　res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">　　　　<span class="built_in">console</span>.log(data);</span><br><span class="line">　　&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个例子和之前的例子实现同样的功能，区别就在于opts对象少了method属性，使用http.get()代替了之前的var req=http.request()和req.end()。由于返回回来的数据是2进制数据，我们需要使用response.setEncoding()实现编码</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;http模块&quot;&gt;&lt;a href=&quot;#http模块&quot; class=&quot;headerlink&quot; title=&quot;http模块&quot;&gt;&lt;/a&gt;http模块&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;node.js提供了HTTP模块,其中封装了一个高效的HTTP服务器和一个简易的HTTP客户端&lt;/li&gt;
&lt;li&gt;http.Server是一个基于事件的HTTP服务器,核心是由node.js下层C++实现的,接口是由JavaScript封装的&lt;/li&gt;
&lt;li&gt;http.request是http客户端工具,用于客户端发送请求
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（六）数值的扩展</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（六）数值的扩展/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-17T03:53:39.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h1><h2 id="1-Number-isFinite-和-Number-isNaN"><a href="#1-Number-isFinite-和-Number-isNaN" class="headerlink" title="(1) Number.isFinite() 和 Number.isNaN()"></a>(1) Number.isFinite() 和 Number.isNaN()</h2><pre><code>用来检查Infinite和NaN这两个特殊值这两个方法仅对数值有效，对于飞数值一律返回false。</code></pre><pre><code class="javascript"><span class="built_in">Number</span>.isFinite(<span class="string">"25"</span>);<span class="comment">//false</span><span class="built_in">isFinite</span>(<span class="string">"25"</span>);<span class="comment">//true</span></code></pre><a id="more"></a>    <h2 id="2-Number-parseInt-Number-parseFloat"><a href="#2-Number-parseInt-Number-parseFloat" class="headerlink" title="(2) Number.parseInt() ,Number.parseFloat()"></a>(2) Number.parseInt() ,Number.parseFloat()</h2><p>ES6将全局方法parseInt()和parseFloat()移植到了Number对象上，这样做的目的是逐步减少全局方法，使语言逐步模块化。</p><h2 id="3-Math的扩展"><a href="#3-Math的扩展" class="headerlink" title="(3) Math的扩展"></a>(3) Math的扩展</h2><pre><code class="javascript"><span class="built_in">Math</span>.trunc() <span class="comment">//用于去除一个数的小数部分，返回其整数部分</span></code></pre><p><strong>数值的扩展图解</strong></p><p><img src="/img/es6/number.jpg" alt="数值的扩展">            </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数值的扩展&quot;&gt;&lt;a href=&quot;#数值的扩展&quot; class=&quot;headerlink&quot; title=&quot;数值的扩展&quot;&gt;&lt;/a&gt;数值的扩展&lt;/h1&gt;&lt;h2 id=&quot;1-Number-isFinite-和-Number-isNaN&quot;&gt;&lt;a href=&quot;#1-Number-isFinite-和-Number-isNaN&quot; class=&quot;headerlink&quot; title=&quot;(1) Number.isFinite() 和 Number.isNaN()&quot;&gt;&lt;/a&gt;(1) Number.isFinite() 和 Number.isNaN()&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;用来检查Infinite和NaN这两个特殊值
这两个方法仅对数值有效，对于飞数值一律返回false。
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;.isFinite(&lt;span class=&quot;string&quot;&gt;&quot;25&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//false&lt;/span&gt;
&lt;span class=&quot;built_in&quot;&gt;isFinite&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;25&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（十一）Generator</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89Generator/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（十一）Generator/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-10T08:20:56.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p>Generator 就是普通函数，有两个特征：一是function关键字后面有一个星号；二是函数体内部使用yield语句定义遍历器的每个成员，即不同的内部状态<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line">hw.next();</span><br><span class="line">hw.next();</span><br><span class="line">hw.next();</span><br></pre></td></tr></table></figure></p><pre><code>Generator的本质，是提供一种可以暂停执行的函数。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Generator&quot;&gt;&lt;a href=&quot;#Generator&quot; class=&quot;headerlink&quot; title=&quot;Generator&quot;&gt;&lt;/a&gt;Generator&lt;/h1&gt;&lt;p&gt;Generator 就是普通函数，有两个特征：一是function关键字后面有一个星号；二是函数体内部使用yield语句定义遍历器的每个成员，即不同的内部状态&lt;br&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（八）函数的扩展</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（八）函数的扩展/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-10T08:07:22.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="（1）-为函数的参数设置默认值"><a href="#（1）-为函数的参数设置默认值" class="headerlink" title="（1） 为函数的参数设置默认值"></a>（1） 为函数的参数设置默认值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span> (<span class="params">x=<span class="number">0</span>,y=<span class="number">0</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何带有默认值的参数，都被是为可选参数，不带默认值的参数，则被视为必需参数<br><a id="more"></a></p><h2 id="（2）rest参数"><a href="#（2）rest参数" class="headerlink" title="（2）rest参数"></a>（2）rest参数</h2><p>ES6引入了rest参数（…变量名），用于获取函数的多于参数，rest参数后面不能再有其他参数，否则会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">of</span> values) &#123;</span><br><span class="line">sum +=value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>);<span class="comment">//10</span></span><br></pre></td></tr></table></figure></p><h2 id="（3）扩展运算符…"><a href="#（3）扩展运算符…" class="headerlink" title="（3）扩展运算符…"></a>（3）扩展运算符…</h2><pre><code>扩展运算符好比rest参数的逆运算，将一个数组转换为用逗号分隔的参数序列。</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> b=[<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> c=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> d=[<span class="number">0</span>,...a,...b,...c];</span><br><span class="line"><span class="built_in">console</span>.log(d);<span class="comment">//[0,1,2,3,4,5,6];</span></span><br></pre></td></tr></table></figure><h2 id="（4）箭头函数-gt"><a href="#（4）箭头函数-gt" class="headerlink" title="（4）箭头函数=&gt;"></a>（4）箭头函数=&gt;</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">等同于：</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line">等同于：<span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>简化函数：</code></pre><pre><code class="javascript">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>{    <span class="keyword">return</span> x*x;    });    <span class="comment">//箭头函数写法</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span>=&gt;</span>x*x);</code></pre><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><pre><code>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象；不可以当作构造函数，即不可以使用new命令，否则报错；不可以使用arguments对象，该对象在函数体内不存在；</code></pre><h2 id="新的知识："><a href="#新的知识：" class="headerlink" title="新的知识："></a>新的知识：</h2><pre><code>1、如果箭头函数不需要参数或者需要多个参数，就是用圆括号代表参数部分    例如： var sum (num1,num2) =&gt; num1+num2;2、如果箭头函数的代码块部分多于一条语句，就要使用大括号将其括起来，并使用return语句返回3、如果箭头函数直接返回一个对象，必须在对象外面加上括号。var getTempItem = id =&gt; ({id:id,name:&quot;Temp&quot;});由于this在箭头函数中被绑定，所以不能用call（），apply（），bind（）修改this指向</code></pre><p><strong>函数的扩展图解</strong></p><p><img src="/img/es6/function.jpg" alt="函数的扩展">                </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;函数的扩展&quot;&gt;&lt;a href=&quot;#函数的扩展&quot; class=&quot;headerlink&quot; title=&quot;函数的扩展&quot;&gt;&lt;/a&gt;函数的扩展&lt;/h1&gt;&lt;h2 id=&quot;（1）-为函数的参数设置默认值&quot;&gt;&lt;a href=&quot;#（1）-为函数的参数设置默认值&quot; class=&quot;headerlink&quot; title=&quot;（1） 为函数的参数设置默认值&quot;&gt;&lt;/a&gt;（1） 为函数的参数设置默认值&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;x=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,y=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y = y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;任何带有默认值的参数，都被是为可选参数，不带默认值的参数，则被视为必需参数&lt;br&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（九）Set 和 Map</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E4%B9%9D%EF%BC%89Set%20%E5%92%8C%20Map/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（九）Set 和 Map/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-10T08:18:09.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a>Set 和 Map</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>Set类似于数组，不过其成员值都是唯一的，没有重复的值。<br>    Set本身是一个构造函数，用来生成Set数据结构。<br>          例如： </p><pre><code class="javascript"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));<span class="keyword">for</span>(i <span class="keyword">of</span> s ){    <span class="built_in">console</span>.log(i);<span class="comment">//2,3,4,5</span>}<span class="comment">//可以用数组对set进行初始化</span><span class="keyword">var</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]);<span class="built_in">console</span>.log(items.size);<span class="comment">//3</span></code></pre><a id="more"></a>    <h3 id="Set结构的方法："><a href="#Set结构的方法：" class="headerlink" title="Set结构的方法："></a>Set结构的方法：</h3><pre><code>  add(value);delete(value);has(value);clear():清除所有成员</code></pre><h3 id="Set结构的属性："><a href="#Set结构的属性：" class="headerlink" title="Set结构的属性："></a>Set结构的属性：</h3><pre><code>Set.prototype.constructor:构造函数，默认就是Set函数Set.prototype.size:返回Set的成员总数//去除数组中重复元素</code></pre><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span> (<span class="params">array</span>) </span>{  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));}</code></pre><p><strong>Set图解</strong></p><p><img src="/img/es6/set.jpg" alt="Set"></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p> Map结构，类似于对象，也是键值对的集合，但是，“键”的范围不限定于字符串，对象也可以当作键。<br>          例如：</p><pre><code class="javascript"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();o = {    p:<span class="string">"Hello World!"</span>;}m.set(o,<span class="string">"content"</span>);<span class="built_in">console</span>.log(m.get(o));<span class="comment">//content</span></code></pre><pre><code>Map的属性：size:返回成员总数；Map的方法:set(key,value);get(key);has(key);delete(key);clear()Map的遍历map.keys():返回键名的遍历器map.values():返回键值的遍历器map.entries():返回所有成员的遍历器</code></pre><p><strong>Map图解</strong></p><p><img src="/img/es6/map.jpg" alt="Map">          </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Set-和-Map&quot;&gt;&lt;a href=&quot;#Set-和-Map&quot; class=&quot;headerlink&quot; title=&quot;Set 和 Map&quot;&gt;&lt;/a&gt;Set 和 Map&lt;/h1&gt;&lt;h2 id=&quot;set&quot;&gt;&lt;a href=&quot;#set&quot; class=&quot;headerlink&quot; title=&quot;set&quot;&gt;&lt;/a&gt;set&lt;/h2&gt;&lt;p&gt;Set类似于数组，不过其成员值都是唯一的，没有重复的值。&lt;br&gt;    Set本身是一个构造函数，用来生成Set数据结构。&lt;br&gt;          例如： &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Set&lt;/span&gt;();
[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;].map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt; =&amp;gt;&lt;/span&gt; s.add(x));
&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; s ){
    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i);&lt;span class=&quot;comment&quot;&gt;//2,3,4,5&lt;/span&gt;
}
&lt;span class=&quot;comment&quot;&gt;//可以用数组对set进行初始化&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; items = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Set&lt;/span&gt;([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]);
&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(items.size);&lt;span class=&quot;comment&quot;&gt;//3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（二） const命令</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%20const%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（二） const命令/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-17T03:54:31.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h1><pre><code>const用来声明常量，一旦声明，其值就不能改变。const与let的作用域相同，只在声明所在的块级作用域内有效。const声明的常量不可重复声明</code></pre><p><strong>const命令图解</strong></p><p><img src="/img/es6/const.jpg" alt="const命令"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;const命令&quot;&gt;&lt;a href=&quot;#const命令&quot; class=&quot;headerlink&quot; title=&quot;const命令&quot;&gt;&lt;/a&gt;const命令&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;const用来声明常量，一旦声明，其值就不能改变。
const与let的作用域相同，
      
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（十二）Promise</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89Promise/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（十二）Promise/</id>
    <published>2018-12-15T07:31:24.743Z</published>
    <updated>2017-09-10T08:33:11.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>ES6原生提供Promise对象。所谓Promise对象，就是代表了未来某个将要发生的事件（通常是一个异步操作）。它的好处在于，有了promise对象，就可以将异步操作的流程表达出来，避免了层层嵌套的回调函数。<br><a id="more"></a></p><h2 id="Promise对象的基本用法："><a href="#Promise对象的基本用法：" class="headerlink" title="Promise对象的基本用法："></a>Promise对象的基本用法：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="comment">/*异步操作成功*/</span>) &#123;</span><br><span class="line">resolve(value);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reject(error);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="comment">//success</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="comment">//failure</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上代码表示，Promise 构造函数接受一个函数作为参数，该函数的两个参数分别为resolve方法和reject方法。如果异步操作成功，则用resolve方法将Promise对象的状态变为成功，否则，用reject方法将状态变为失败。</p><p>promise实例生成以后，可以使用then方法分别制定resolve方法和reject方法的回调函数。<br>    用Promise对象实现Ajax操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function"><span class="keyword">function</span> (<span class="params">resolve,reject</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">client.open(<span class="string">"GET"</span>,url);</span><br><span class="line">client.onreadystatechange = handler;</span><br><span class="line">client.responseType = <span class="string">"json"</span>;</span><br><span class="line">client.setRequestHeader(<span class="string">"Accept"</span>,<span class="string">"application/json"</span>);</span><br><span class="line">client.send();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.readyState === <span class="keyword">this</span>.DONE) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">resolve(<span class="keyword">this</span>.response);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reject(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/post.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>)</span>&#123;</span><br><span class="line"><span class="comment">//continue</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line"><span class="comment">//handle errors</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="Promise-对象有三种状态："><a href="#Promise-对象有三种状态：" class="headerlink" title="Promise 对象有三种状态："></a>Promise 对象有三种状态：</h2><p>(1)Fulfilled 可以理解为成功的状态<br>(2)Rejected 可以理解为失败的状态<br>(3)Pending 既不是 Fulfilld 也不是 Rejected 的状态，可以理解为 Promise 对象实例创建时候的初始状态</p><p>Promise.all 可以接收一个元素为 Promise 对象的数组作为参数，当这个数组里面所有的 Promise 对象都变为 resolve 时，该方法才会返回。</p><p><strong>Promise图解</strong></p><p><img src="/img/es6/promise.jpg" alt="Promise"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h1&gt;&lt;p&gt;ES6原生提供Promise对象。所谓Promise对象，就是代表了未来某个将要发生的事件（通常是一个异步操作）。它的好处在于，有了promise对象，就可以将异步操作的流程表达出来，避免了层层嵌套的回调函数。&lt;br&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>Promise用法</title>
    <link href="http://yoursite.com/2018/12/15/promise/"/>
    <id>http://yoursite.com/2018/12/15/promise/</id>
    <published>2018-12-15T07:31:24.727Z</published>
    <updated>2017-09-17T03:57:00.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="Promise的概念"><a href="#Promise的概念" class="headerlink" title="Promise的概念"></a>Promise的概念</h2><p>Promise 对象用于异步(asynchronous)计算.。一个Promise对象代表着一个还未完成，但预期将来会完成的操作。</p><p><strong>它也可以理解为</strong><br>是一个包含了兼容promise规范then方法的对象或函数<br>我们可以这样理解，每一个promise只要返回的可以then的都可以。就像上面举例返回的this一样，只要每一个都返回this，她就可以无限的链式下去，<br>这里的this约定为每一个对象或函数返回的都是兼容promise规范then方法。<br><a id="more"></a></p><h3 id="Promise的几种状态："><a href="#Promise的几种状态：" class="headerlink" title="Promise的几种状态："></a>Promise的几种状态：</h3><ul><li>pending：初始状态，即等待操作的执行</li><li>fulfilled：成功的操作</li><li>rejected：失败的操作</li></ul><p>pending的状态既可以转为fulfilled，也可以转为rejected，当状态发生改变时，promise.then(onFulfilled, onRejected)方法将被调用</p><h2 id="Promise的基本用法"><a href="#Promise的基本用法" class="headerlink" title="Promise的基本用法"></a>Promise的基本用法</h2><p>1.首先创建一个Promise的实例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">if</span>(success)&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>构造函数的参数Function中带有两个函数对象resolve和reject，二者都是返回一个Promise对象</p><ul><li>resolve用在处理执行成功的场景，Promise从pending转为fulfilled状态时调用</li><li>reject用在处理执行失败的场景，Promise从pending转为rejected状态时调用</li></ul><p>2.调用then()方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//成功时调用</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//失败时调用</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="用Promise来封装异步函数"><a href="#用Promise来封装异步函数" class="headerlink" title="用Promise来封装异步函数"></a>用Promise来封装异步函数</h2><p>Node.js中的IO操作都是异步的，因此在写异步程序的过程中容易掉进回调大坑</p><p>知道了Promise的基本调用过程，我们就可以用来封装异步的函数了</p><p>1.定义函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendRequest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> req = http.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">            res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">                data += chunk;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">//成功后调用</span></span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        req.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//失败后调用</span></span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        req.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.调用函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sendRequest().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h2><p>1.一般用法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个异步promise</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 异步请求</span></span><br><span class="line">    fetch(<span class="string">'xxxx'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 返回数据</span></span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise 执行完后的回调</span></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//todo sth</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//处理异常</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>Promise.all 所有promise 都返回才执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// data[0] 是p1 返回的数据， data[1] 是 p2 返回的数据 ， 依此类推</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Promise.race 只要有一个promise 返回就执行 ， 应用场景：比如探寻多个Url 是否有效，只要有一个url有效就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([p1, p2, p3]).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h1&gt;&lt;h2 id=&quot;Promise的概念&quot;&gt;&lt;a href=&quot;#Promise的概念&quot; class=&quot;headerlink&quot; title=&quot;Promise的概念&quot;&gt;&lt;/a&gt;Promise的概念&lt;/h2&gt;&lt;p&gt;Promise 对象用于异步(asynchronous)计算.。一个Promise对象代表着一个还未完成，但预期将来会完成的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它也可以理解为&lt;/strong&gt;&lt;br&gt;是一个包含了兼容promise规范then方法的对象或函数&lt;br&gt;我们可以这样理解，每一个promise只要返回的可以then的都可以。就像上面举例返回的this一样，只要每一个都返回this，她就可以无限的链式下去，&lt;br&gt;这里的this约定为每一个对象或函数返回的都是兼容promise规范then方法。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://yoursite.com/categories/node/"/>
    
    
      <category term="promise" scheme="http://yoursite.com/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>理解Promise</title>
    <link href="http://yoursite.com/2018/12/15/%E7%90%86%E8%A7%A3Promise/"/>
    <id>http://yoursite.com/2018/12/15/理解Promise/</id>
    <published>2018-12-15T07:31:24.727Z</published>
    <updated>2017-09-17T03:54:08.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理解Promise"><a href="#理解Promise" class="headerlink" title="理解Promise"></a>理解Promise</h2><p>Promise可能是不同于日常直觉，为了理解它，一些重要原理必须记牢：　.then()总是返回一个新的promise.，如下面代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = readFile()</span><br><span class="line"><span class="keyword">var</span> promise2 = promise.then(readAnotherFile, <span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure></p><p>这里then的参数readAnotherFile, console.error是代表异步操作成功后的动作onFulfilled或失败后的动作OnRejected，也就是说，读取文件成功后执行readAnotherFile函数，否则失败打印记录错误。这种实现是两个中只有一种可能。<br><a id="more"></a></p><p>我们再看下面上述代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = readFile()</span><br><span class="line"><span class="keyword">var</span> promise2 = promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> readAnotherFile() <span class="comment">// 如果readFile成功，执行readAnotherFile</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err) <span class="comment">// 如果readFile不成功，记录，但是还是执行readAnotherFile</span></span><br><span class="line">  <span class="keyword">return</span> readAnotherFile()</span><br><span class="line">&#125;)</span><br><span class="line">promise2.then(<span class="built_in">console</span>.log, <span class="built_in">console</span>.error) <span class="comment">// readAnotherFile函数的执行结果</span></span><br></pre></td></tr></table></figure></p><p>因为then返回一个promise，它意味着promise能够被chain串行链条花，这样能避免回调地狱：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">readFile()</span><br><span class="line">  .then(readAnotherFile)</span><br><span class="line">  .then(doSomethingElse)</span><br><span class="line">  .then(...)</span><br></pre></td></tr></table></figure><h2 id="Promise法则有两部分必须分离："><a href="#Promise法则有两部分必须分离：" class="headerlink" title="Promise法则有两部分必须分离："></a>Promise法则有两部分必须分离：</h2><p>（1）. then()总是返回一个新的promise，每次你调用它，它不管回调做什么，因为.then()在回调被调用之前已经给了你一个承诺promise，回调的行为只影响承诺promise的实施，如果回调返回一个值，那么promise将使用那个值，如果这个值是一个promise，返回这个promise实施后的值给这个值，如果回调抛出错误，promise将拒绝错误。<br>（2）. 被.then()返回的promise是一个新的promise，它不同于那些.then()被调用的promise，promise长长的链条有时会好些隐藏这个事实，不管如何，每次.then()调用都会产生一个新的promise，这里必须注意的是你真正需要考虑的是你最后调用.then()可能代表失败，那么如果你不捕获这种失败，那么容易导致你的错误exception消失。</p><p>一些人认为.then()串联链条调用很类似fluent风格，但是长长的promise链条会让人迷惑，最后切分为一个个有意义的函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTasks</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> $http.get(<span class="string">'http://example.com/api/v1/tasks'</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> response.data;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMyTasks</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> getTasks()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> filterTasks(tasks, &#123;</span><br><span class="line">        owner: user.username</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，两个函数各自获得一个promise，携带了一个回调函数。</p><h2 id="有趣的Promise"><a href="#有趣的Promise" class="headerlink" title="有趣的Promise"></a>有趣的Promise</h2><p>同样的promise能够接受任何数目的回调，当一个Promise被解决实施后，其中所有回调函数都会被调用，此外，一个promise在被解决实施后，甚至可以接受一个新的回调，这些回调完成能以正常方式被调用，这就允许我们使用回调实现简单形式的缓存：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tasksPromise; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTasks</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  taskPromise = taskPromise || getTasksFromTheServer();</span><br><span class="line">  <span class="keyword">return</span> taskPromise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个案例中，getTasks()函数可以被任意次数调用，它总是返回铜牙的promise，其中函数getTasksFromTheServer()却只是被调用一次。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;理解Promise&quot;&gt;&lt;a href=&quot;#理解Promise&quot; class=&quot;headerlink&quot; title=&quot;理解Promise&quot;&gt;&lt;/a&gt;理解Promise&lt;/h2&gt;&lt;p&gt;Promise可能是不同于日常直觉，为了理解它，一些重要原理必须记牢：　.then()总是返回一个新的promise.，如下面代码：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; promise = readFile()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; promise2 = promise.then(readAnotherFile, &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.error)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里then的参数readAnotherFile, console.error是代表异步操作成功后的动作onFulfilled或失败后的动作OnRejected，也就是说，读取文件成功后执行readAnotherFile函数，否则失败打印记录错误。这种实现是两个中只有一种可能。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://yoursite.com/categories/node/"/>
    
    
      <category term="promise" scheme="http://yoursite.com/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>表单验证</title>
    <link href="http://yoursite.com/2018/12/15/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"/>
    <id>http://yoursite.com/2018/12/15/表单验证/</id>
    <published>2018-12-15T07:31:24.727Z</published>
    <updated>2017-09-17T03:54:12.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="表单验证整理"><a href="#表单验证整理" class="headerlink" title="表单验证整理"></a>表单验证整理</h2><h2 id="匹配Email地址"><a href="#匹配Email地址" class="headerlink" title="匹配Email地址"></a>匹配Email地址</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"><span class="comment">//对电子邮件的验证</span></span><br><span class="line"><span class="keyword">var</span> myreg = <span class="regexp">/^([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+\.[a-zA-Z]&#123;2,3&#125;$/</span>;</span><br><span class="line"><span class="keyword">if</span>(!myreg.test(obj))&#123;</span><br><span class="line">alert(<span class="string">'请输入有效的邮箱！'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="验证手机号"><a href="#验证手机号" class="headerlink" title="验证手机号"></a>验证手机号</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validatemobile</span>(<span class="params">mobile</span>) </span>&#123; </span><br><span class="line"><span class="keyword">if</span>(mobile.length==<span class="number">0</span>) &#123; </span><br><span class="line">alert(<span class="string">'手机号码不能为空！'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(mobile.length!=<span class="number">11</span>) &#123; </span><br><span class="line">alert(<span class="string">'请输入有效的手机号码，需是11位！'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myreg = <span class="regexp">/^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(18[0-9]&#123;1&#125;))+\d&#123;8&#125;)$/</span>; </span><br><span class="line"><span class="keyword">if</span>(!myreg.test(mobile)) &#123; </span><br><span class="line">alert(<span class="string">'请输入有效的手机号码！'</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只能是英文字母和数字"><a href="#只能是英文字母和数字" class="headerlink" title="只能是英文字母和数字"></a>只能是英文字母和数字</h2><h3 id="只能是英文字母"><a href="#只能是英文字母" class="headerlink" title="只能是英文字母"></a>只能是英文字母</h3><ul><li>验证只能是字母<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkZm</span>(<span class="params">zm</span>)</span>&#123; </span><br><span class="line"><span class="keyword">var</span> zmReg=<span class="regexp">/^[a-zA-Z]*$/</span>; </span><br><span class="line"><span class="keyword">if</span>(zm!=<span class="string">""</span>&amp;&amp;!zmReg.test(zm))&#123; </span><br><span class="line">alert(<span class="string">"只能是英文字母！"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="只能是数字"><a href="#只能是数字" class="headerlink" title="只能是数字"></a>只能是数字</h3><ul><li>验证只能为数字 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkNumber</span>(<span class="params">obj</span>)</span>&#123; </span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^[0-9]+$/</span>; </span><br><span class="line"><span class="keyword">if</span>(obj!=<span class="string">""</span>&amp;&amp;!reg.test(obj))&#123; </span><br><span class="line">alert(<span class="string">'只能输入数字！'</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="只能是英文字母和数字-1"><a href="#只能是英文字母和数字-1" class="headerlink" title="只能是英文字母和数字"></a>只能是英文字母和数字</h3><ul><li>验证只能是字母和数字 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkZmOrNum</span>(<span class="params">zmnum</span>)</span>&#123; </span><br><span class="line"><span class="keyword">var</span> zmnumReg=<span class="regexp">/^[0-9a-zA-Z]*$/</span>; </span><br><span class="line"><span class="keyword">if</span>(zmnum!=<span class="string">""</span>&amp;&amp;!zmnumReg.test(zmnum))&#123; </span><br><span class="line">alert(<span class="string">"只能输入是字母或者数字,请重新输入"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="长度限制"><a href="#长度限制" class="headerlink" title="长度限制"></a>长度限制</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;<span class="number">1.</span> 长度限制&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;form name=a onsubmit="return test()"&gt; </span></span><br><span class="line"><span class="regexp">&lt;textarea name="b" cols="40" rows="6" placeholder="不能超过50个字符！"&gt;&lt;/</span>textarea&gt;</span><br><span class="line">&lt;br /&gt; </span><br><span class="line">&lt;input type=<span class="string">"submit"</span> name=<span class="string">"Submit"</span> value=<span class="string">"check"</span>&gt; </span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script language="javascript"&gt; </span></span><br><span class="line"><span class="regexp">function test() &#123; </span></span><br><span class="line"><span class="regexp">if(document.a.b.value.length&gt;50) &#123; </span></span><br><span class="line"><span class="regexp">alert("不能超过50个字符！"); </span></span><br><span class="line"><span class="regexp">document.a.b.focus(); </span></span><br><span class="line"><span class="regexp">return false; </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125; </span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h2 id="只能是汉字"><a href="#只能是汉字" class="headerlink" title="只能是汉字"></a>只能是汉字</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;<span class="number">2.</span> 只能是汉字 &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;input type="text" onblur="isChinese(this.value)" placeholder="请输入中文！" /</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isChinese</span>(<span class="params">obj</span>)</span>&#123; </span><br><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/^[\u0391-\uFFE5]+$/</span>; </span><br><span class="line"><span class="keyword">if</span>(obj!=<span class="string">""</span>&amp;&amp;!reg.test(obj))&#123; </span><br><span class="line">alert(<span class="string">'必须输入中文！'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证是否是浮点数"><a href="#验证是否是浮点数" class="headerlink" title="验证是否是浮点数"></a>验证是否是浮点数</h3><ul><li>str要验证的数据  </li><li><p>匹配返回true 不匹配返回false  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> function isDouble(str)&#123;</span><br><span class="line">    if(str==null||str==&quot;&quot;) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">    var result=str.match(/^[-\+]?\d+(\.\d+)?$/);</span><br><span class="line">    if(result==null)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配qq"><a href="#匹配qq" class="headerlink" title="匹配qq"></a>匹配qq</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function isQq(str)&#123;</span><br><span class="line">    if(str==null||str==&quot;&quot;) return false;</span><br><span class="line">    var result=str.match(/^[1-9]\d&#123;4,12&#125;$/);</span><br><span class="line">    if(result==null)return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="匹配邮政编码"><a href="#匹配邮政编码" class="headerlink" title="匹配邮政编码"></a>匹配邮政编码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isZipCode</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">null</span>||str==<span class="string">""</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> result=str.match(<span class="regexp">/^[0-9]&#123;6&#125;$/</span>);</span><br><span class="line">    <span class="keyword">if</span>(result==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配money"><a href="#匹配money" class="headerlink" title="匹配money"></a>匹配money</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMoney</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">null</span>||str==<span class="string">""</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> result=str.match(<span class="regexp">/^(([1-9]\d*)|(([0-9]&#123;1&#125;|[1-9]+)\.[0-9]&#123;1,2&#125;))$/</span>);</span><br><span class="line">    <span class="keyword">if</span>(result==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配URL"><a href="#匹配URL" class="headerlink" title="匹配URL"></a>匹配URL</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUrl</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">null</span>||str==<span class="string">""</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> result=str.match(<span class="regexp">/^http:\/\/[A-Za-z0-9]+\.[A-Za-z0-9]+[\/=\?%\-&amp;_~`@[\]\’:+!]*([^&lt;&gt;\"])*$/</span>);</span><br><span class="line">    <span class="keyword">if</span>(result==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配密码，以字母开头，长度在6-12之间，只能包含字符、数字和下划线。"><a href="#匹配密码，以字母开头，长度在6-12之间，只能包含字符、数字和下划线。" class="headerlink" title="匹配密码，以字母开头，长度在6-12之间，只能包含字符、数字和下划线。"></a>匹配密码，以字母开头，长度在6-12之间，只能包含字符、数字和下划线。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPwd</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">null</span>||str==<span class="string">""</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> result=str.match(<span class="regexp">/^[a-zA-Z]\\w&#123;6,12&#125;$/</span>);</span><br><span class="line">    <span class="keyword">if</span>(result==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否为合法字符-a-zA-Z0-9"><a href="#判断是否为合法字符-a-zA-Z0-9" class="headerlink" title="判断是否为合法字符(a-zA-Z0-9-_)"></a>判断是否为合法字符(a-zA-Z0-9-_)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRightfulString</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">null</span>||str==<span class="string">""</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> result=str.match(<span class="regexp">/^[A-Za-z0-9_-]+$/</span>);</span><br><span class="line">    <span class="keyword">if</span>(result==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符验证，只能包含中文、英文、数字、下划线等字符"><a href="#字符验证，只能包含中文、英文、数字、下划线等字符" class="headerlink" title="字符验证，只能包含中文、英文、数字、下划线等字符"></a>字符验证，只能包含中文、英文、数字、下划线等字符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringCheck</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">null</span>||str==<span class="string">""</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> result=str.match(<span class="regexp">/^[a-zA-Z0-9\u4e00-\u9fa5-_]+$/</span>);</span><br><span class="line">    <span class="keyword">if</span>(result==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否包含中英文特殊字符，除英文”-”字符外"><a href="#判断是否包含中英文特殊字符，除英文”-”字符外" class="headerlink" title="判断是否包含中英文特殊字符，除英文”-_”字符外"></a>判断是否包含中英文特殊字符，除英文”-_”字符外</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isContainsSpecialChar</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">null</span>||str==<span class="string">""</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="built_in">RegExp</span>(<span class="regexp">/[(\ )(\`)(\~)(\!)(\@)(\#)(\$)(\%)(\^)(\&amp;)(\*)(\()(\))(\+)(\=)(\|)(\&#123;)(\&#125;)(\')(\:)(\;)(\')(',)(\[)(\])(\.)(\&lt;)(\&gt;)(\/)(\?)(\~)(\！)(\@)(\#)(\￥)(\%)(\…)(\&amp;)(\*)(\（)(\）)(\—)(\+)(\|)(\&#123;)(\&#125;)(\【)(\】)(\‘)(\；)(\：)(\”)(\“)(\’)(\。)(\，)(\、)(\？)]+/</span>);   </span><br><span class="line">    <span class="keyword">return</span> reg.test(str);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配URL-1"><a href="#匹配URL-1" class="headerlink" title="匹配URL"></a>匹配URL</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUrl</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">null</span>||str==<span class="string">""</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> result=str.match(<span class="regexp">/^http:\/\/[A-Za-z0-9]+\.[A-Za-z0-9]+[\/=\?%\-&amp;_~`@[\]\’:+!]*([^&lt;&gt;\"])*$/</span>);</span><br><span class="line">    <span class="keyword">if</span>(result==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配身份证号码"><a href="#匹配身份证号码" class="headerlink" title="匹配身份证号码"></a>匹配身份证号码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIdCardNo</span>(<span class="params">num</span>)</span>&#123; </span><br><span class="line">　   <span class="comment">//　 if (isNaN(num)) &#123;alert("输入的不是数字！"); return false;&#125; </span></span><br><span class="line">　　 <span class="keyword">var</span> len = num.length, re; </span><br><span class="line">　　 <span class="keyword">if</span> (len == <span class="number">15</span>) &#123;</span><br><span class="line">　　 re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/^(\d&#123;6&#125;)()?(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\w)$/</span>); </span><br><span class="line">　　 &#125;<span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">18</span>) &#123;</span><br><span class="line">　　 re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/^(\d&#123;6&#125;)()?(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;3&#125;)(\w)$/</span>); </span><br><span class="line">　　 &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">alert(<span class="string">"输入的数字位数不对。"</span>); <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line">　　 <span class="keyword">var</span> a = num.match(re); </span><br><span class="line">　　 <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123; </span><br><span class="line">　　 <span class="keyword">if</span> (len==<span class="number">15</span>) &#123; </span><br><span class="line">　　 <span class="keyword">var</span> D = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"19"</span>+a[<span class="number">3</span>]+<span class="string">"/"</span>+a[<span class="number">4</span>]+<span class="string">"/"</span>+a[<span class="number">5</span>]); </span><br><span class="line">　　 <span class="keyword">var</span> B = D.getYear()==a[<span class="number">3</span>]&amp;&amp;(D.getMonth()+<span class="number">1</span>)==a[<span class="number">4</span>]&amp;&amp;D.getDate()==a[<span class="number">5</span>]; </span><br><span class="line">　　 &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">　　 <span class="keyword">var</span> D = <span class="keyword">new</span> <span class="built_in">Date</span>(a[<span class="number">3</span>]+<span class="string">"/"</span>+a[<span class="number">4</span>]+<span class="string">"/"</span>+a[<span class="number">5</span>]); </span><br><span class="line">　　 <span class="keyword">var</span> B = D.getFullYear()==a[<span class="number">3</span>]&amp;&amp;(D.getMonth()+<span class="number">1</span>)==a[<span class="number">4</span>]&amp;&amp;D.getDate()==a[<span class="number">5</span>]; </span><br><span class="line">　　 &#125; </span><br><span class="line">　　 <span class="keyword">if</span> (!B) &#123;</span><br><span class="line">alert(<span class="string">"输入的身份证号 "</span>+ a[<span class="number">0</span>] +<span class="string">" 里出生日期不对。"</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line">　　 &#125; </span><br><span class="line">　　 <span class="keyword">if</span>(!re.test(num))&#123;</span><br><span class="line">alert(<span class="string">"身份证最后一位只能是数字和字母。"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">　　 <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;表单验证整理&quot;&gt;&lt;a href=&quot;#表单验证整理&quot; class=&quot;headerlink&quot; title=&quot;表单验证整理&quot;&gt;&lt;/a&gt;表单验证整理&lt;/h2&gt;&lt;h2 id=&quot;匹配Email地址&quot;&gt;&lt;a href=&quot;#匹配Email地址&quot; class=&quot;headerlink&quot; title=&quot;匹配Email地址&quot;&gt;&lt;/a&gt;匹配Email地址&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//对电子邮件的验证&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; myreg = &lt;span class=&quot;regexp&quot;&gt;/^([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+\.[a-zA-Z]&amp;#123;2,3&amp;#125;$/&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!myreg.test(obj))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		alert(&lt;span class=&quot;string&quot;&gt;&#39;请输入有效的邮箱！&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="form" scheme="http://yoursite.com/categories/form/"/>
    
    
      <category term="form" scheme="http://yoursite.com/tags/form/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（七）数组的扩展</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（七）数组的扩展/</id>
    <published>2018-12-15T07:31:24.727Z</published>
    <updated>2017-09-10T07:18:43.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h1><h2 id="1-Array-of"><a href="#1-Array-of" class="headerlink" title="(1) Array.of()"></a>(1) Array.of()</h2><p>用于将一组值转换为数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="2-find"><a href="#2-find" class="headerlink" title="(2) find()"></a>(2) find()</h2><p>用于找出第一个符合条件的数组元素，它的参数是一个回调函数，所有数组元素依次遍历该回调函数，直到找出第一个返回值为true的元素，然后返回该元素，否则返回undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>] .find(<span class="function"><span class="keyword">function</span> (<span class="params">value,index,arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">//10</span></span><br></pre></td></tr></table></figure></p><h2 id="4-findIndex"><a href="#4-findIndex" class="headerlink" title="(4)findIndex()"></a>(4)findIndex()</h2><p>返回第一个符合条件的数组元素的位置，如果所有元素都不符合，则返回-1</p><h2 id="5-fill"><a href="#5-fill" class="headerlink" title="(5) fill()"></a>(5) fill()</h2><p>使用给定值填充一个数组</p><h2 id="6-数组推导"><a href="#6-数组推导" class="headerlink" title="(6) 数组推导"></a>(6) 数组推导</h2><p>数组推导：允许直接通过现有数组生成新数组。</p><pre><code class="javascript"><span class="keyword">var</span> a1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];<span class="keyword">var</span> a2 = [<span class="keyword">for</span> (i <span class="keyword">of</span> a1) i*<span class="number">2</span>];<span class="comment">//[2,4,6,8]</span><span class="keyword">for</span> <span class="keyword">of</span> 后面还可以附加<span class="keyword">if</span>语句，用来设定循环的限制条件<span class="keyword">var</span> years = [<span class="number">2000</span>,<span class="number">2004</span>,<span class="number">2008</span>,<span class="number">2012</span>,<span class="number">2016</span>];[<span class="keyword">for</span> (year <span class="keyword">of</span> years) <span class="keyword">if</span> (year &gt;<span class="number">2007</span>)];<span class="comment">//[2008,2012,2016]</span>[<span class="keyword">for</span> (year <span class="keyword">of</span> years) <span class="keyword">if</span>(year&gt;<span class="number">2007</span>&amp;&amp; year&lt;<span class="number">2013</span>)];<span class="comment">//[2008,2012]</span></code></pre><p><strong>数值的扩展图解</strong></p><p><img src="/img/es6/Array.jpg" alt="数值的扩展">        </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数组的扩展&quot;&gt;&lt;a href=&quot;#数组的扩展&quot; class=&quot;headerlink&quot; title=&quot;数组的扩展&quot;&gt;&lt;/a&gt;数组的扩展&lt;/h1&gt;&lt;h2 id=&quot;1-Array-of&quot;&gt;&lt;a href=&quot;#1-Array-of&quot; class=&quot;headerlink&quot; title=&quot;(1) Array.of()&quot;&gt;&lt;/a&gt;(1) Array.of()&lt;/h2&gt;&lt;p&gt;用于将一组值转换为数组&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.of(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;//[1,2,3,4]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（三） 解构赋值</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%20%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（三） 数组的解构/</id>
    <published>2018-12-15T07:31:24.727Z</published>
    <updated>2017-09-17T03:54:26.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行复制，这被称为解构<br>例如 var [a,b,c] = [1,2,3]//本质上属于模式匹配，只要两边的模式相同，左边的变量就会被赋予相应的值。<br>注意：解构只能用于数组或者对象。其他原始类型的值都可以转化为相应的对象，但是undefined和null不能转化为对象，所以不能够解构。<br>对象的解构：<br>数组的元素是按照次序排列的，变量的取值由它的位置决定，而对象的属性没有次序，变量必须与属性同名，才能取到正确的值<br><a id="more"></a>    </p><h2 id="解构的用途："><a href="#解构的用途：" class="headerlink" title="解构的用途："></a>解构的用途：</h2><p>（1）交换变量的值<br>（2）从函数返回多个值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [a,b,c] = example();</span><br></pre></td></tr></table></figure></p><p>(3) 函数参数的定义<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">funciton f(&#123;x,y,z&#125;)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">f(&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>,<span class="attr">z</span>:<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>(4) 函数参数的默认值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax= <span class="function"><span class="keyword">function</span> (<span class="params">url,&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">cache = <span class="literal">true</span>,</span><br><span class="line">complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">crossDomain = <span class="literal">false</span>,</span><br><span class="line">global = <span class="literal">true</span>.</span><br><span class="line">&#125;) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>解构赋值图解</strong></p><p><img src="/img/es6/jiegou.jpg" alt="解构赋值"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;解构赋值&quot;&gt;&lt;a href=&quot;#解构赋值&quot; class=&quot;headerlink&quot; title=&quot;解构赋值&quot;&gt;&lt;/a&gt;解构赋值&lt;/h1&gt;&lt;p&gt;ES6允许按照一定模式，从数组和对象中提取值，对变量进行复制，这被称为解构&lt;br&gt;例如 var [a,b,c] = [1,2,3]//本质上属于模式匹配，只要两边的模式相同，左边的变量就会被赋予相应的值。&lt;br&gt;注意：解构只能用于数组或者对象。其他原始类型的值都可以转化为相应的对象，但是undefined和null不能转化为对象，所以不能够解构。&lt;br&gt;对象的解构：&lt;br&gt;数组的元素是按照次序排列的，变量的取值由它的位置决定，而对象的属性没有次序，变量必须与属性同名，才能取到正确的值&lt;br&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6系列（一） let命令</title>
    <link href="http://yoursite.com/2018/12/15/es6/ES6%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%20let%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/12/15/es6/ES6系列（一） let命令/</id>
    <published>2018-12-15T07:31:24.727Z</published>
    <updated>2017-09-17T03:54:22.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h2><pre><code>ES6新增了let命令，用于声明变量，用let声明的变量，只在let命令所在的代码块内有效。let其实是为JavaScript新增了块级作用域。</code></pre><pre><code class="JavaScript">{  <span class="keyword">let</span> a,b,rest;  [a,b]=[<span class="number">1</span>,<span class="number">2</span>];  <span class="built_in">console</span>.log(a,b); <span class="comment">//1, 2</span>}</code></pre><p><strong>let命令图解</strong></p><p><img src="/img/es6/let.jpg" alt="let命令图解"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;let命令&quot;&gt;&lt;a href=&quot;#let命令&quot; class=&quot;headerlink&quot; title=&quot;let命令&quot;&gt;&lt;/a&gt;let命令&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;ES6新增了let命令，用于声明变量，用let声明的变量，只在let命令所在的代码块内有效。
let
      
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
</feed>
